// Copyright © 2026 Groups.io, Inc.
// SPDX-License-Identifier: Apache-2.0

{% import "strings" %}
{% import "encoding/json" %}

{% code
// TerminalInfo represents a terminal window for display.
type TerminalInfo struct {
    Session   string
    Window    string
    IsRemote  bool
    Worktree  string // Worktree name (e.g., "main", "feature-branch")
}

// ShortcutInfo represents a keyboard shortcut for the terminal page.
// Window must start with a prefix character indicating the target type:
//   ~name           = log viewer (e.g., ~nginx)
//   #name           = service (e.g., #api)
//   @worktree - win = local terminal (e.g., @main - dev)
//   !name           = remote window (e.g., !admin)
type ShortcutInfo struct {
    Key    string `json:"key"`
    Window string `json:"window"`
}

// NotificationSettings represents browser notification configuration.
type NotificationSettings struct {
    Enabled      bool     `json:"enabled"`
    Events       []string `json:"events"`
    FailuresOnly bool     `json:"failures_only"`
    Sound        bool     `json:"sound"`
}

type TerminalPage struct {
    BasePage
    Terminals []TerminalInfo
}

// ServiceInfo represents a service for the terminal picker.
type ServiceInfo struct {
    Name           string         `json:"name"`
    Status         string         `json:"status"`
    ParserType     string         `json:"parser_type,omitempty"`     // "json", "logfmt", "regex", "none"
    Columns        []string       `json:"columns,omitempty"`         // Deprecated: use Layout
    ColumnWidths   map[string]int `json:"column_widths,omitempty"`   // Deprecated: use Layout
    Layout         []LayoutColumn `json:"layout,omitempty"`          // Full layout configuration
    TimestampField string         `json:"timestamp_field,omitempty"` // Parser's timestamp field name
    LevelField     string         `json:"level_field,omitempty"`     // Parser's level field name
    MessageField   string         `json:"message_field,omitempty"`   // Parser's message field name
}

// LinkInfo represents a link for the terminal picker.
type LinkInfo struct {
    Name string `json:"name"`
    URL  string `json:"url"`
}

// LayoutColumn represents a column in the log display layout (for JSON serialization).
type LayoutColumn struct {
    Field     string   `json:"field,omitempty"`
    Type      string   `json:"type,omitempty"`       // "" or "kvpairs"
    Keys      []string `json:"keys,omitempty"`       // For kvpairs
    MaxPairs  int      `json:"max_pairs,omitempty"`  // For kvpairs (0 = all)
    MinWidth  int      `json:"min_width,omitempty"`
    MaxWidth  int      `json:"max_width,omitempty"`
    Align     string   `json:"align,omitempty"`
    Optional  bool     `json:"optional,omitempty"`
    Timestamp bool     `json:"timestamp,omitempty"`  // Use timestamp formatting
}

// LogViewerInfo represents a log viewer for the terminal picker.
type LogViewerInfo struct {
    Name           string         `json:"name"`
    Columns        []string       `json:"columns"`         // Columns to display (empty = default) - DEPRECATED
    ColumnWidths   map[string]int `json:"column_widths"`   // Column widths in characters (0 = fill) - DEPRECATED
    Layout         []LayoutColumn `json:"layout"`          // Full layout configuration
    TimestampField string         `json:"timestamp_field"` // Parser's timestamp field name
    LevelField     string         `json:"level_field"`     // Parser's level field name
    MessageField   string         `json:"message_field"`   // Parser's message field name
}

type TerminalWindowPage struct {
    BasePage
    Session       string
    Window        string
    IsRemote      bool
    ViewType      string // "local", "remote", "service", "editor", "logviewer"
    ServiceName   string // Only for ViewType="service"
    LogViewerName string // Only for ViewType="logviewer"
    WorktreeName  string // Current worktree name (e.g., "main", "feature-branch")
    ProjectName   string
    Shortcuts     []ShortcutInfo
    Notifications NotificationSettings
    Services      []ServiceInfo
    Links         []LinkInfo
    LogViewers    []LogViewerInfo
}

%}

// ShortcutsJSON streams the shortcuts as JSON for JavaScript (raw, unescaped).
{% func (p *TerminalWindowPage) ShortcutsJSON() %}{% if len(p.Shortcuts) == 0 %}[]{% else %}{% code b, _ := json.Marshal(p.Shortcuts) %}{%z= b %}{% endif %}{% endfunc %}

// shortcutKeyDisplay formats a shortcut key like "cmd+l" as "<kbd>Cmd</kbd> + <kbd>L</kbd>".
{% func shortcutKeyDisplay(key string) %}
{% code
    parts := strings.Split(key, "+")
    for i, part := range parts {
        part = strings.TrimSpace(part)
        // Capitalize first letter
        if len(part) > 0 {
            parts[i] = strings.ToUpper(part[:1]) + part[1:]
        }
        // Handle common modifier names
        switch strings.ToLower(part) {
        case "cmd", "meta":
            parts[i] = "Cmd"
        case "ctrl", "control":
            parts[i] = "Ctrl"
        case "alt", "option":
            parts[i] = "Alt"
        case "shift":
            parts[i] = "Shift"
        case "backspace":
            parts[i] = "Backspace"
        }
    }
%}
{% for i, part := range parts %}{% if i > 0 %} + {% endif %}<kbd>{%s part %}</kbd>{% endfor %}
{% endfunc %}

// NotificationsJSON streams the notification settings as JSON for JavaScript.
{% func (p *TerminalWindowPage) NotificationsJSON() %}{% code b, _ := json.Marshal(p.Notifications) %}{%z= b %}{% endfunc %}

// ServicesJSON streams the services list as JSON for JavaScript.
{% func (p *TerminalWindowPage) ServicesJSON() %}{% code b, _ := json.Marshal(p.Services) %}{%z= b %}{% endfunc %}

// LinksJSON streams the links list as JSON for JavaScript.
{% func (p *TerminalWindowPage) LinksJSON() %}{% code b, _ := json.Marshal(p.Links) %}{%z= b %}{% endfunc %}

// LogViewersJSON streams the log viewers list as JSON for JavaScript.
{% func (p *TerminalWindowPage) LogViewersJSON() %}{% code b, _ := json.Marshal(p.LogViewers) %}{%z= b %}{% endfunc %}

{% code

// SessionDisplayName returns the branch name for display (e.g., "main", "demovideos")
func (p *TerminalWindowPage) SessionDisplayName() string {
    if p.ProjectName == "" {
        return p.Session
    }
    // Convert project name to tmux format (. → _)
    projectPrefix := strings.ReplaceAll(p.ProjectName, ".", "_")
    if p.Session == projectPrefix {
        return "main"
    }
    // Strip project prefix and hyphen
    if strings.HasPrefix(p.Session, projectPrefix+"-") {
        return p.Session[len(projectPrefix)+1:]
    }
    return p.Session
}
%}

{% func (p *TerminalPage) Render() %}
{%= p.Header() %}

<div class="row">
    <div class="col-lg-8">
        <div class="card mb-4">
            <div class="card-header">
                <i class="fa-solid fa-terminal"></i> Terminals
            </div>
            <div class="card-body p-0">
                {% if len(p.Terminals) > 0 %}
                <table class="table table-dark table-hover mb-0">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th>Session</th>
                            <th>Type</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for _, term := range p.Terminals %}
                        {% code
                            var termURL string
                            if term.IsRemote {
                                termURL = "/terminal/remote/" + term.Window
                            } else {
                                termURL = "/terminal/local/" + term.Worktree + "/" + term.Window
                            }
                        %}
                        <tr>
                            <td>
                                <a href="{%s termURL %}" class="text-decoration-none text-accent">
                                    {%s term.Window %}
                                </a>
                            </td>
                            <td>
                                <small class="text-muted">
                                    {% if term.IsRemote %}!{% else %}@{% endif %}{%s term.Worktree %}
                                </small>
                            </td>
                            <td>
                                {% if term.IsRemote %}
                                <span class="badge bg-warning text-dark"><i class="fa-solid fa-globe"></i> Remote</span>
                                {% else %}
                                <span class="badge bg-secondary"><i class="fa-solid fa-terminal"></i> Local</span>
                                {% endif %}
                            </td>
                        </tr>
                        {% endfor %}
                    </tbody>
                </table>
                {% else %}
                <div class="p-3 text-muted">No terminal sessions available</div>
                {% endif %}
            </div>
        </div>
    </div>

    <div class="col-lg-4">
        <div class="card mb-4">
            <div class="card-header">
                <i class="fa-solid fa-keyboard"></i> Keyboard Shortcuts
            </div>
            <div class="card-body">
                <table class="table table-sm mb-0">
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>P</kbd></td>
                        <td>Terminal picker</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>E</kbd></td>
                        <td>Toggle Code/Terminal</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>Backspace</kbd></td>
                        <td>History picker (recent screens)</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>L</kbd></td>
                        <td>Jump to log</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>H</kbd></td>
                        <td>Show help</td>
                    </tr>
                </table>
            </div>
        </div>
    </div>
</div>

{%= p.Footer() %}
{% endfunc %}

{% func (p *TerminalWindowPage) Render() %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{%s p.Title %} - Trellis</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link href="/static/css/theme.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet">
    <script>
        (function() {
            const saved = localStorage.getItem('trellis-theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            const theme = saved || (prefersDark ? 'dark' : 'light');
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>
</head>
<body>
<nav class="navbar navbar-expand-lg">
    <div class="container-fluid">
        <a class="navbar-brand" href="/"><img src="/static/img/logo.png" alt="Trellis" height="50"></a>
        <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
            <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarNav">
            <ul class="navbar-nav">
            </ul>

            <!-- Terminal controls in navbar -->
            <div class="d-flex align-items-center gap-2 ms-3">
                <select id="navSelect" class="form-select form-select-sm">
                    <option value="{%s p.Session %}/{%s p.Window %}" selected>@{%s p.SessionDisplayName() %} - {%s p.Window %}</option>
                </select>

                {% if p.ViewType == "local" %}
                <div class="btn-group" role="group">
                    <button id="showTerminalBtn" class="btn btn-sm btn-terminal active" onclick="showTerminal()">
                        <i class="fa-solid fa-terminal"></i>
                    </button>
                    <button id="showCodeBtn" class="btn btn-sm btn-terminal" onclick="showCode()">
                        <i class="fa-solid fa-code"></i>
                    </button>
                </div>

                <select id="workflowSelect" class="form-select form-select-sm" style="width: 160px;">
                    <option value="">Workflow...</option>
                </select>
                {% endif %}
            </div>

            <div class="d-flex align-items-center gap-3 ms-auto">
                {% if p.Worktree != nil %}
                <span class="navbar-text">
                    <i class="fa-solid fa-code-branch text-accent"></i> {%s p.Worktree.Name() %} ({%s p.Worktree.Branch %})
                </span>
                {% endif %}
                <button class="btn btn-sm btn-terminal" onclick="showHelp()" title="Keyboard Shortcuts (Cmd/Ctrl+?)">
                    <i class="fa-solid fa-keyboard"></i>
                </button>
                <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
                    <i class="fa-solid fa-sun" id="theme-icon-light"></i>
                    <i class="fa-solid fa-moon" id="theme-icon-dark" style="display:none;"></i>
                </button>
            </div>
        </div>
    </div>
</nav>
<div class="container-fluid mt-4">
<!-- Theme toggle handled by NavScript below -->

<style>
    /* Remove top margin from container on terminal page */
    .container-fluid.mt-4 { margin-top: 0 !important; }

    /* Navbar terminal controls */
    .navbar #navSelect { width: 280px; }
    .select2-container--default .select2-selection--single {
        background: var(--trellis-input-bg);
        border-color: var(--trellis-input-border);
        color: var(--bs-body-color);
        height: 38px;
        padding-top: 4px;
    }
    .select2-container--default .select2-selection--single .select2-selection__rendered {
        color: var(--bs-body-color);
    }
    .select2-container--default .select2-selection--single .select2-selection__arrow b {
        border-color: var(--trellis-text-muted) transparent transparent transparent;
    }
    .select2-dropdown {
        background: var(--trellis-dropdown-bg);
        border-color: var(--trellis-dropdown-border);
    }
    .select2-results__option {
        color: var(--bs-body-color);
    }
    .select2-container--default .select2-results__option--highlighted[aria-selected] {
        background: var(--bs-primary);
        color: #fff;
    }
    #terminal-wrapper {
        height: calc(100vh - 90px);
        background: var(--trellis-terminal-bg);
        padding: 10px;
        border-radius: 4px;
    }
    #terminal {
        height: 100%;
        width: 100%;
    }
    .btn-terminal {
        background: var(--trellis-card-bg);
        color: var(--bs-primary);
        border: 1px solid var(--bs-primary);
    }
    .btn-terminal:hover {
        background: var(--bs-primary);
        color: #fff;
    }
    /* Style xterm scrollbar - uses terminal background as base */
    .xterm .xterm-viewport::-webkit-scrollbar {
        width: 14px;
    }
    .xterm .xterm-viewport::-webkit-scrollbar-track {
        background: var(--trellis-terminal-bg);
    }
    .xterm .xterm-viewport::-webkit-scrollbar-thumb {
        background: var(--trellis-scrollbar-thumb);
        border-radius: 4px;
    }
    .xterm .xterm-viewport::-webkit-scrollbar-thumb:hover {
        background: var(--trellis-scrollbar-hover);
    }
    #code-wrapper {
        height: calc(100vh - 90px);
        background: var(--trellis-pre-bg);
        border-radius: 4px;
    }
    #code-iframe {
        width: 100%;
        height: 100%;
        border-radius: 4px;
    }
    #workflow-wrapper {
        height: calc(100vh - 90px);
        background: var(--trellis-terminal-bg);
        padding: 10px;
        border-radius: 4px;
    }
    #workflow-wrapper .workflow-header {
        color: var(--bs-body-color);
    }
    #workflow-output {
        height: calc(100% - 40px);
        overflow-y: auto;
        background: var(--trellis-pre-bg);
        border-radius: 4px;
        padding: 10px;
        margin: 0;
        font-size: 13px;
        color: var(--bs-body-color);
    }
    #workflow-output code {
        display: block;
        color: var(--bs-body-color);
        font-family: 'JetBrains Mono', Monaco, 'Courier New', monospace;
        line-height: 1.4;
    }
    #workflowSelect {
        background: var(--trellis-input-bg);
        border-color: var(--trellis-input-border);
        color: var(--bs-body-color);
    }
    .btn-group .btn-terminal.active {
        background: var(--bs-primary);
        color: #fff;
    }
    /* Service log view */
    #service-wrapper, #logviewer-wrapper {
        height: calc(100vh - 90px);
        background: #000;
        border-radius: 4px;
        display: flex;
        flex-direction: column;
    }
    .service-header {
        background: var(--trellis-card-bg);
        padding: 10px 15px;
        border-radius: 4px 4px 0 0;
        display: flex;
        align-items: center;
        gap: 15px;
        flex-shrink: 0;
    }
    .service-header-left {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .service-header-center {
        flex: 1;
        display: flex;
        justify-content: center;
    }
    .service-header .service-name {
        font-weight: bold;
        font-size: 1.1em;
    }
    .service-header .service-status {
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 0.85em;
    }
    .service-header .service-status.running { background: #198754; color: white; }
    .service-header .service-status.stopped { background: #6c757d; color: white; }
    .service-header .service-status.crashed { background: #dc3545; color: white; }
    .service-header .service-status.starting { background: #0dcaf0; color: black; }
    .service-header .service-controls {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    #service-log {
        flex: 1;
        overflow-y: auto;
        background: #1a1a1a;
        padding: 10px;
        margin: 0;
        font-family: 'JetBrains Mono', Monaco, monospace;
        font-size: 13px;
        color: #d4d4d4;
        white-space: pre-wrap;
        word-break: break-all;
    }
    #service-log::-webkit-scrollbar {
        width: 14px;
    }
    #service-log::-webkit-scrollbar-track {
        background: #1a1a1a;
    }
    #service-log::-webkit-scrollbar-thumb {
        background: #444;
        border-radius: 4px;
    }
    #service-log-table {
        flex: 1;
        overflow: auto;
        background: var(--trellis-pre-bg);
        font-family: 'JetBrains Mono', Monaco, monospace;
        font-size: 13px;
    }
    /* Log viewer specific styles */
    .logviewer-header {
        background: var(--trellis-card-bg);
        padding: 8px 15px;
        border-radius: 4px 4px 0 0;
        display: flex;
        align-items: center;
        gap: 15px;
        flex-shrink: 0;
    }
    .logviewer-header-left {
        display: flex;
        align-items: center;
        gap: 10px;
    }
    .logviewer-header-center {
        flex: 1;
        display: flex;
        justify-content: center;
    }
    .logviewer-header-right {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .logviewer-name {
        font-weight: bold;
        font-size: 1.1em;
    }
    .logviewer-connection-status {
        padding: 2px 8px;
        border-radius: 3px;
        font-size: 0.85em;
        background: #6c757d;
        color: white;
    }
    .logviewer-connection-status.connected { background: #198754; }
    .logviewer-connection-status.disconnected { background: #dc3545; }
    .logviewer-filter-bar {
        display: flex;
        align-items: center;
        background: var(--trellis-input-bg);
        border: 1px solid var(--trellis-input-border);
        border-radius: 4px;
        padding: 4px 10px;
        min-width: 350px;
    }
    .logviewer-filter-bar i {
        color: #888;
        margin-right: 8px;
    }
    .logviewer-filter-bar input {
        flex: 1;
        background: transparent;
        border: none;
        color: var(--bs-body-color);
        font-size: 13px;
        outline: none;
    }
    .logviewer-filter-bar input::placeholder {
        color: #666;
    }
    .logviewer-filter-clear {
        background: transparent;
        border: none;
        color: #888;
        cursor: pointer;
        padding: 2px 5px;
    }
    .logviewer-filter-clear:hover {
        color: #fff;
    }
    .logviewer-mode-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        background: var(--trellis-input-bg);
        border: 1px solid var(--trellis-input-border);
        border-radius: 4px;
        padding: 4px 10px;
        color: var(--bs-body-color);
        font-size: 13px;
        cursor: pointer;
    }
    .logviewer-mode-btn:hover {
        background: var(--trellis-card-bg-hover);
    }
    .logviewer-mode-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #198754;
    }
    .logviewer-mode-dot.paused {
        background: #ffc107;
    }
    .logviewer-newlines-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        background: #0d6efd;
        border: none;
        border-radius: 4px;
        padding: 4px 10px;
        color: white;
        font-size: 13px;
        cursor: pointer;
    }
    .logviewer-newlines-btn:hover {
        background: #0b5ed7;
    }
    .logviewer-log {
        flex: 1;
        overflow: auto;
        background: var(--trellis-pre-bg);
        padding: 0;
        margin: 0;
        font-family: 'JetBrains Mono', Monaco, monospace;
        font-size: 13px;
        color: var(--bs-body-color);
    }
    .logviewer-log::-webkit-scrollbar {
        width: 14px;
    }
    .logviewer-log::-webkit-scrollbar-track {
        background: var(--trellis-scrollbar-track);
    }
    .logviewer-log::-webkit-scrollbar-thumb {
        background: var(--trellis-scrollbar-thumb);
        border-radius: 4px;
    }
    /* Flexbox row layout */
    .logviewer-entry {
        display: flex;
        gap: 10px;
        align-items: baseline;
        padding: 2px 10px;
        cursor: pointer;
    }
    .logviewer-entry:nth-child(odd) {
        background: var(--trellis-pre-bg);
    }
    .logviewer-entry:nth-child(even) {
        background: var(--trellis-logviewer-even, var(--trellis-table-hover));
    }
    [data-theme="dark"] .logviewer-entry:nth-child(even) {
        background: #252a32;
    }
    .logviewer-entry:hover {
        background: var(--trellis-dropdown-hover);
    }
    .logviewer-entry.selected {
        background: rgba(86, 171, 47, 0.2);
    }
    /* Column styles */
    .logviewer-entry > span {
        flex-shrink: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .logviewer-entry .column-timestamp {
        color: var(--trellis-text-muted);
    }
    .logviewer-entry .column-level {
        text-transform: uppercase;
        font-weight: bold;
    }
    .logviewer-entry .column-level.level-trace { color: var(--trellis-text-muted); }
    .logviewer-entry .column-level.level-debug { color: var(--trellis-text-muted); }
    .logviewer-entry .column-level.level-info { color: #3b82f6; }
    .logviewer-entry .column-level.level-warn { color: #f59e0b; }
    .logviewer-entry .column-level.level-error { color: #ef4444; }
    .logviewer-entry .column-level.level-fatal { color: #dc2626; background: rgba(220, 38, 38, 0.15); padding: 0 4px; border-radius: 2px; }
    .logviewer-entry .column-message {
        white-space: pre;
    }
    .logviewer-expanded {
        position: absolute;
        right: 0;
        top: 50px;
        bottom: 0;
        width: 400px;
        background: var(--trellis-card-bg);
        border-left: 1px solid var(--trellis-input-border);
        display: flex;
        flex-direction: column;
        z-index: 10;
    }
    .logviewer-expanded-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px 15px;
        border-bottom: 1px solid var(--trellis-input-border);
        font-weight: bold;
    }
    .logviewer-expanded-header button {
        background: transparent;
        border: none;
        color: var(--trellis-text-muted);
        cursor: pointer;
    }
    .logviewer-expanded-header button:hover {
        color: var(--bs-body-color);
    }
    .logviewer-expanded-content {
        flex: 1;
        overflow-y: auto;
        padding: 15px;
        font-family: 'JetBrains Mono', Monaco, monospace;
        font-size: 12px;
    }
    .logviewer-expanded-content .field {
        margin-bottom: 8px;
    }
    .logviewer-expanded-content .field-name {
        color: var(--trellis-text-muted);
        margin-right: 8px;
    }
    .logviewer-expanded-content .field-name .copy-btn {
        margin-right: 6px;
        cursor: pointer;
        opacity: 0.5;
        font-size: 11px;
        transition: opacity 0.15s, color 0.15s;
    }
    .logviewer-expanded-content .field-name .copy-btn:hover {
        opacity: 1;
    }
    .logviewer-expanded-content .field-name .copy-btn.copied {
        opacity: 1;
        color: var(--bs-success);
    }
    .logviewer-expanded-content .field-value {
        color: var(--bs-body-color);
    }
    .logviewer-expanded-content .raw-log {
        margin-top: 15px;
        padding: 10px;
        background: var(--trellis-pre-bg);
        border-radius: 4px;
        white-space: pre-wrap;
        word-break: break-all;
    }
    /* Help modal styling */
    .shortcut-help-modal .modal-content {
        background: var(--trellis-card-bg);
        color: var(--bs-body-color);
    }
    .shortcut-help-modal .modal-header {
        border-bottom-color: var(--trellis-input-border);
    }
    .shortcut-help-modal .modal-footer {
        border-top-color: var(--trellis-input-border);
    }
    .shortcut-help-modal kbd {
        background: var(--trellis-input-bg);
        border: 1px solid var(--trellis-input-border);
        border-radius: 3px;
        padding: 2px 6px;
        font-family: monospace;
    }
    .shortcut-help-modal table {
        width: 100%;
    }
    .shortcut-help-modal td {
        padding: 8px 0;
        border-bottom: 1px solid var(--trellis-input-border);
    }
    .shortcut-help-modal tr:last-child td {
        border-bottom: none;
    }
</style>

<div id="terminal-wrapper">
    <div id="terminal"></div>
</div>

<div id="code-wrapper" style="display: none;">
    <iframe id="code-iframe" src="" frameborder="0"></iframe>
</div>

<div id="workflow-wrapper" style="display: none;">
    <div class="workflow-header d-flex justify-content-between align-items-center mb-2">
        <span id="workflow-title"><i class="fa-solid fa-bolt"></i> Workflow Output</span>
        <button class="btn btn-sm btn-outline-secondary" onclick="showTerminal()" title="Back to terminal (Cmd/Ctrl+Backspace)">
            <i class="fa-solid fa-xmark"></i> Close
        </button>
    </div>
    <pre id="workflow-output"><code></code></pre>
</div>

<div id="service-wrapper" style="display: none;">
    <div class="service-header">
        <div class="service-header-left">
            <span class="service-name" id="service-name">Service</span>
            <span class="service-status" id="service-status">unknown</span>
        </div>
        <div class="service-header-center" id="service-filter-container" style="display: none;">
            <div class="logviewer-filter-bar">
                <i class="fa-solid fa-search"></i>
                <input type="text" id="service-filter" placeholder="Filter: level:error msg:~&quot;timeout&quot;"
                       onkeyup="applyServiceLogFilter(event)" />
                <button class="logviewer-filter-clear" onclick="clearServiceLogFilter()" title="Clear filter">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
        </div>
        <div class="service-controls">
            <button class="logviewer-mode-btn" id="service-mode-btn" onclick="toggleServiceLogFollowing()" style="display: none;">
                <span id="service-mode-indicator">Following</span>
                <span class="logviewer-mode-dot" id="service-mode-dot"></span>
            </button>
            <button class="logviewer-newlines-btn" id="service-newlines-btn" onclick="jumpToLatestServiceLogs()" style="display: none;">
                <span id="service-newlines-count">+0 new lines</span>
                <i class="fa-solid fa-arrow-down"></i>
            </button>
            <button class="btn btn-sm btn-outline-danger" onclick="stopService()" id="service-stop-btn" title="Stop service">
                <i class="fa-solid fa-stop"></i> Stop
            </button>
            <button class="btn btn-sm btn-outline-success" onclick="restartService()" id="service-restart-btn" title="Restart service">
                <i class="fa-solid fa-rotate"></i> Restart
            </button>
            <button class="btn btn-sm btn-outline-secondary" onclick="clearServiceLog()" title="Clear log">
                <i class="fa-solid fa-trash"></i> Clear
            </button>
            <button class="btn btn-sm btn-outline-secondary" onclick="showTerminal()" title="Back to terminal">
                <i class="fa-solid fa-xmark"></i> Close
            </button>
        </div>
    </div>
    <pre id="service-log"></pre>
    <div id="service-log-table" class="logviewer-log" style="display: none;"></div>
    <div id="service-expanded" class="logviewer-expanded" style="display: none;">
        <div class="logviewer-expanded-header">
            <span>Entry Details</span>
            <button onclick="closeServiceExpanded()"><i class="fa-solid fa-times"></i></button>
        </div>
        <div class="logviewer-expanded-content" id="service-expanded-content"></div>
    </div>
</div>

<div id="logviewer-wrapper" style="display: none;">
    <div class="logviewer-header">
        <div class="logviewer-header-left">
            <span class="logviewer-name" id="logviewer-name">Log Viewer</span>
            <span class="logviewer-connection-status" id="logviewer-status">connecting...</span>
        </div>
        <div class="logviewer-header-center">
            <div class="logviewer-filter-bar">
                <i class="fa-solid fa-search"></i>
                <input type="text" id="logviewer-filter" placeholder="Filter: level:error msg:~&quot;timeout&quot;"
                       onkeyup="applyLogViewerFilter(event)" />
                <button class="logviewer-filter-clear" onclick="clearLogViewerFilter()" title="Clear filter">
                    <i class="fa-solid fa-times"></i>
                </button>
            </div>
        </div>
        <div class="logviewer-header-right">
            <button class="logviewer-mode-btn" id="logviewer-mode-btn" onclick="toggleLogViewerFollowing()">
                <span id="logviewer-mode-indicator">Following</span>
                <span class="logviewer-mode-dot" id="logviewer-mode-dot"></span>
            </button>
            <button class="logviewer-newlines-btn" id="logviewer-newlines-btn" onclick="jumpToLatestLogs()" style="display: none;">
                <span id="logviewer-newlines-count">+0 new lines</span>
                <i class="fa-solid fa-arrow-down"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary" id="logviewer-history-btn" onclick="openHistorySearchModal()" title="Search history">
                <i class="fa-solid fa-clock-rotate-left"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary" id="logviewer-timestamp-btn" onclick="toggleLogViewerTimestamp()" title="Toggle timestamp format">
                <i class="fa-solid fa-clock"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary" onclick="clearLogViewerLog()" title="Clear log">
                <i class="fa-solid fa-trash"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary" onclick="showTerminal()" title="Back to terminal">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
    </div>
    <div id="logviewer-log" class="logviewer-log"></div>
    <div id="logviewer-expanded" class="logviewer-expanded" style="display: none;">
        <div class="logviewer-expanded-header">
            <span>Entry Details</span>
            <button onclick="closeLogViewerExpanded()"><i class="fa-solid fa-times"></i></button>
        </div>
        <div class="logviewer-expanded-content" id="logviewer-expanded-content"></div>
    </div>
</div>

<!-- Keyboard Shortcuts Help Modal -->
<div class="modal fade shortcut-help-modal" id="shortcutHelpModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="fa-solid fa-keyboard"></i> Keyboard Shortcuts</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <table>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>P</kbd></td>
                        <td>Open terminal picker</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>/</kbd></td>
                        <td>Open workflow picker</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>E</kbd></td>
                        <td>Toggle Terminal / Code view</td>
                    </tr>
                    <tr>
                        <td><kbd>Escape</kbd></td>
                        <td>Close workflow output</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>Backspace</kbd></td>
                        <td>Close workflow output / History picker</td>
                    </tr>
                    <tr>
                        <td><kbd>Cmd/Ctrl</kbd> + <kbd>H</kbd></td>
                        <td>Show this help</td>
                    </tr>
                    {% if len(p.Shortcuts) > 0 %}
                    <tr><td colspan="2" style="padding-top: 12px;"><strong>Custom Shortcuts</strong></td></tr>
                    {% for _, sc := range p.Shortcuts %}
                    <tr>
                        <td>{%= shortcutKeyDisplay(sc.Key) %}</td>
                        <td>Jump to {%s sc.Window %}</td>
                    </tr>
                    {% endfor %}
                    {% endif %}
                </table>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Log History Search Modal -->
<div class="modal fade" id="historySearchModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title"><i class="fa-solid fa-clock-rotate-left"></i> Search Log History</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="mb-3">
                    <label class="form-label">Time Range</label>
                    <div class="row g-2">
                        <div class="col-6">
                            <div class="input-group input-group-sm">
                                <span class="input-group-text">From</span>
                                <input type="text" class="form-control" id="history-start" placeholder="1h, 6:30am, 2024-01-15">
                            </div>
                        </div>
                        <div class="col-6">
                            <div class="input-group input-group-sm">
                                <span class="input-group-text">To</span>
                                <input type="text" class="form-control" id="history-end" placeholder="now, 7:00am">
                            </div>
                        </div>
                    </div>
                    <div class="mt-2">
                        <small class="text-muted">Quick: </small>
                        <button type="button" class="btn btn-outline-secondary btn-sm py-0 px-1" onclick="setHistoryRange('1h')">1h</button>
                        <button type="button" class="btn btn-outline-secondary btn-sm py-0 px-1" onclick="setHistoryRange('4h')">4h</button>
                        <button type="button" class="btn btn-outline-secondary btn-sm py-0 px-1" onclick="setHistoryRange('today')">today</button>
                        <button type="button" class="btn btn-outline-secondary btn-sm py-0 px-1" onclick="setHistoryRange('yesterday')">yesterday</button>
                    </div>
                </div>
                <div class="mb-3">
                    <label class="form-label">Search Pattern (grep)</label>
                    <input type="text" class="form-control form-control-sm" id="history-grep" placeholder="error|timeout|panic">
                </div>
                <div class="mb-3">
                    <label class="form-label">Context Lines</label>
                    <div class="row g-2">
                        <div class="col-4">
                            <div class="input-group input-group-sm">
                                <span class="input-group-text">-B</span>
                                <input type="number" class="form-control" id="history-before" value="0" min="0" max="100" title="Lines before match">
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="input-group input-group-sm">
                                <span class="input-group-text">-A</span>
                                <input type="number" class="form-control" id="history-after" value="0" min="0" max="100" title="Lines after match">
                            </div>
                        </div>
                        <div class="col-4">
                            <div class="input-group input-group-sm">
                                <span class="input-group-text">-C</span>
                                <input type="number" class="form-control" id="history-context" value="0" min="0" max="100" title="Lines before and after" onchange="syncContextInputs(this)">
                            </div>
                        </div>
                    </div>
                    <small class="text-muted">Like grep: -B before, -A after, -C both</small>
                </div>
                <div id="history-error" class="alert alert-danger py-2 mb-0" style="display: none;"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" onclick="executeHistorySearch()" id="history-search-btn">
                    <i class="fa-solid fa-search"></i> Search
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Workflow Confirm Modal -->
<div class="modal fade" id="workflowConfirmModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="workflowConfirmTitle">Confirm</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <p id="workflowConfirmMessage"></p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="workflowConfirmYes">Yes, Run</button>
            </div>
        </div>
    </div>
</div>

<!-- Workflow Inputs Modal -->
<div class="modal fade" id="workflowInputsModal" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="workflowInputsTitle">Workflow Inputs</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <form id="workflowInputsForm">
                    <!-- Dynamic inputs will be inserted here -->
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="workflowInputsContinue">Continue</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/jquery@3.7.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
{%= NavScript(p.SessionID(), p.ShortcutsJSON(), "terminal") %}
<script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/reconnecting-websocket@4.4.0/dist/reconnecting-websocket-iife.min.js"></script>
<script src="/static/js/logviewer.js"></script>
<script>
    const initialSession = '{%s JSAttr(p.Session) %}';
    const initialWindow = '{%s JSAttr(p.Window) %}';
    const initialIsRemote = {%v p.IsRemote %};
    const initialViewType = '{%s JSAttr(p.ViewType) %}';
    const initialServiceName = '{%s JSAttr(p.ServiceName) %}';
    const initialLogViewerName = '{%s JSAttr(p.LogViewerName) %}';
    const initialWorktree = '{%s JSAttr(p.WorktreeName) %}';
    const projectName = '{%s JSAttr(p.ProjectName) %}';
    const customShortcuts = {%= p.ShortcutsJSON() %};
    const notificationSettings = {%= p.NotificationsJSON() %};
    const initialServices = {%= p.ServicesJSON() %};
    const initialLinks = {%= p.LinksJSON() %};
    const initialLogViewers = {%= p.LogViewersJSON() %};

    // Map of terminalKey -> {term, fitAddon, ws, container, isRemote}
    let terminals = {};
    let currentTerminalKey = null;
    let currentWorktree = initialWorktree || 'main';

    // Debug mode for scroll issues - enable via: window.TRELLIS_DEBUG_SCROLL = true
    window.TRELLIS_DEBUG_SCROLL = false;
    let lastScrollState = {}; // Track scroll state per terminal

    // Track user's scroll position when viewing history (not at bottom)
    // This gets restored after events that reset scroll to top
    let userScrollPosition = {}; // terminalKey -> { scrollTop, timestamp }
    const SCROLL_RESTORE_WINDOW = 2000; // ms - how long to keep trying to restore

    // Clear history if server was restarted (session ID changed)
    const currentSessionID = '{%s JSAttr(p.SessionID()) %}';
    const storedSessionID = sessionStorage.getItem('trellis-session-id');
    if (storedSessionID !== currentSessionID) {
        sessionStorage.setItem('trellis-session-id', currentSessionID);
        sessionStorage.removeItem('trellis-nav-history');
    }

    // Use shared navigation from TrellisNav (defined in header.qtpl)
    let refreshingPicker = false; // Flag to prevent change handler during picker refresh
    let originalNavOptions = []; // Store original option order for restoring after history mode

    // Aliases for TrellisNav functions for cleaner code
    const pushToScreenHistory = TrellisNav.pushToHistory;
    const normalizeHistoryKey = TrellisNav.normalizeKey;
    const formatPickerOption = TrellisNav.formatOption;

    // Get the previous screen key (for backwards compatibility)
    function getPreviousScreenKey() {
        const history = TrellisNav.getHistory();
        return history.length > 0 ? history[0] : null;
    }

    // Refresh terminal picker (restore original options and reinitialize select2)
    function refreshTerminalPicker() {
        if (originalNavOptions.length === 0) return;

        const select = document.getElementById('navSelect');
        const currentVal = $('#navSelect').val();

        // Restore original options
        select.innerHTML = '';
        for (const optData of originalNavOptions) {
            const opt = document.createElement('option');
            opt.value = optData.value;
            opt.textContent = optData.textContent;
            // Copy all dataset properties
            for (const [key, val] of Object.entries(optData.dataset)) {
                opt.dataset[key] = val;
            }
            if (optData.value === currentVal) {
                opt.selected = true;
            }
            select.appendChild(opt);
        }

        // Reinitialize select2 with original handlers
        refreshingPicker = true;
        $('#navSelect').select2('destroy').select2({
            placeholder: 'Select terminal...',
            width: '300px',
            templateResult: formatPickerOption,
            templateSelection: formatPickerOption
        }).on('select2:select', handleNormalSelection);
        if (currentVal) {
            $('#navSelect').val(currentVal).trigger('change.select2');
        }
        refreshingPicker = false;
    }

    // Handle normal (non-history) selection
    function handleNormalSelection(e) {
        if (refreshingPicker) return;

        const selectedOption = this.options[this.selectedIndex];
        const isRemote = selectedOption.dataset.isRemote === 'true';
        const isOutput = selectedOption.dataset.isOutput === 'true';
        const isService = selectedOption.dataset.isService === 'true';
        const isLink = selectedOption.dataset.isLink === 'true';
        const isLogViewer = selectedOption.dataset.isLogViewer === 'true';
        const isPage = selectedOption.dataset.isPage === 'true';
        const isTerminal = selectedOption.dataset.isTerminal === 'true';
        const isEditor = selectedOption.dataset.isEditor === 'true';

        if (isPage) {
            // Push current terminal URL to history before navigating away
            // This allows cmd-backspace to return to this terminal from the page
            if (currentTerminalKey) {
                const url = window.location.pathname;
                pushToScreenHistory(url);
            }
            // Navigate to page URL
            window.location.href = this.value;
            return;
        } else if (isLink) {
            const url = selectedOption.dataset.linkUrl;
            const windowName = selectedOption.dataset.linkWindowName;
            let win = linkWindows[windowName];
            let reused = false;
            if (win && !win.closed) {
                try {
                    win.location.href = url;
                    win.focus();
                    reused = true;
                } catch (e) {}
            }
            if (!reused) {
                win = window.open(url, windowName);
                linkWindows[windowName] = win;
            }
            $('#navSelect').val(null).trigger('change.select2');
            return;
        } else if (isService) {
            const serviceName = selectedOption.dataset.serviceName;
            showService(serviceName);
        } else if (isLogViewer) {
            const logViewerName = selectedOption.dataset.logViewerName;
            showLogViewer(logViewerName);
        } else if (isOutput) {
            const worktree = selectedOption.dataset.worktree;
            showOutput(worktree);
        } else if (isEditor) {
            showCode();
        } else if (isTerminal) {
            // Use dataset for session/window, construct terminal key
            const session = selectedOption.dataset.session;
            const window = selectedOption.dataset.window;
            const termKey = session + '/' + window + (isRemote ? '?remote=1' : '');
            switchTerminal(termKey, isRemote);
        } else {
            // Fallback: try to extract from URL value
            switchTerminal(this.value, isRemote);
        }
    }

    // Get terminal theme colors from CSS variables
    function getTerminalTheme() {
        const style = getComputedStyle(document.documentElement);
        return {
            background: style.getPropertyValue('--trellis-terminal-bg').trim() || '#000000',
            foreground: style.getPropertyValue('--trellis-terminal-fg').trim() || '#d4d4d4',
            cursor: style.getPropertyValue('--trellis-terminal-cursor').trim() || '#56AB2F',
            cursorAccent: style.getPropertyValue('--trellis-terminal-bg').trim() || '#000000',
            selectionBackground: style.getPropertyValue('--trellis-terminal-selection').trim() || 'rgba(86, 171, 47, 0.3)'
        };
    }

    // Listen for theme changes and update all terminals
    window.addEventListener('trellis-theme-change', () => {
        const theme = getTerminalTheme();
        Object.values(terminals).forEach(termData => {
            termData.term.options.theme = theme;
        });
    });

    // Convert tmux session name to worktree name
    function sessionToWorktree(session) {
        const projectPrefix = projectName.replace(/\./g, '_');
        if (session === projectPrefix) {
            return 'main';
        }
        if (session.startsWith(projectPrefix + '-')) {
            return session.substring(projectPrefix.length + 1);
        }
        return session;
    }

    // Convert worktree name to tmux session name
    function worktreeToSession(worktree) {
        const projectPrefix = projectName.replace(/\./g, '_');
        if (worktree === 'main') {
            return projectPrefix;
        }
        return projectPrefix + '-' + worktree;
    }

    // Workflow output per worktree: worktree -> { title, html, text }
    let workflowOutputs = {};

    // Service log state
    let currentServiceName = null;
    let serviceLogPollTimer = null;
    let lastLogLength = 0;
    // Structured service log state (when parser is configured)
    let serviceLogConfig = null;        // Current service's logging config
    let serviceLogEntries = [];         // All parsed entries
    let serviceLogFilteredEntries = []; // Entries matching filter
    let serviceLogFilter = '';          // Current filter query
    let serviceLogFollowing = true;     // Auto-scroll to bottom
    let serviceLogNewLinesCount = 0;    // Count of new lines when paused
    let serviceLogLayout = [];          // Full layout configuration
    let serviceLogFieldMap = {};        // Maps field names to entry properties
    let serviceLogFieldNames = {};      // Maps standard fields back to original names
    let serviceLogSelectedEntry = null; // Currently expanded entry
    let serviceLogTimestampAbsolute = true; // Show absolute timestamps

    // Log viewer state
    let currentLogViewerName = null;
    let logViewerWs = null;
    let logViewerReconnectTimer = null;
    let logViewerEntries = [];          // All entries received
    let logViewerFilteredEntries = []; // Entries matching current filter
    let logViewerFollowing = true;      // Auto-scroll to bottom
    let logViewerNewLinesCount = 0;     // Count of new lines when paused
    let logViewerFilter = '';           // Current filter query
    let logViewerTimestampAbsolute = true; // Show absolute timestamps
    let logViewerRelativeTimeInterval = null; // Timer for updating relative timestamps
    let logViewerSelectedEntry = null;  // Currently expanded entry
    let logViewerColumns = ['timestamp', 'level', 'message']; // Default columns
    let logViewerColumnWidths = {};     // Column widths from config
    let logViewerLayout = [];           // Full layout config (for kvpairs support)
    let logViewerFieldMap = {};         // Maps column names to entry fields (e.g., "time" -> timestamp)
    let logViewerFieldNames = { timestamp: 'timestamp', level: 'level', message: 'message' }; // Original field names from config
    let logViewerOldestSeq = null;      // Oldest sequence number we have (for loading more)
    let logViewerLoadingMore = false;   // Prevent multiple load requests
    let logViewerNoMoreEntries = false; // True when buffer exhausted

    // Browser notifications
    let notificationsEnabled = false;
    function initNotifications() {
        if (!notificationSettings.enabled) return;
        if (!('Notification' in window)) return;

        if (Notification.permission === 'granted') {
            notificationsEnabled = true;
            connectEventWebSocket();
        } else if (Notification.permission !== 'denied') {
            Notification.requestPermission().then(permission => {
                if (permission === 'granted') {
                    notificationsEnabled = true;
                    connectEventWebSocket();
                }
            });
        }
    }

    // Single unified event WebSocket for notifications, service status, and worktree updates
    let eventWs = null;

    function connectEventWebSocket() {
        // Avoid duplicate connections
        if (eventWs && (eventWs.readyState === WebSocket.CONNECTING || eventWs.readyState === WebSocket.OPEN)) {
            return;
        }

        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        eventWs = new ReconnectingWebSocket(wsProtocol + '//' + window.location.host + '/api/v1/events/ws');

        eventWs.onmessage = (event) => {
            try {
                const msg = JSON.parse(event.data);
                if (msg.type) {
                    // Handle notifications
                    if (notificationsEnabled) {
                        handleEventNotification(msg);
                    }
                    // Handle service status updates
                    if (msg.type.startsWith('service.')) {
                        handleServiceStatusUpdate(msg);
                    }
                    // Handle worktree updates
                    if (msg.type.startsWith('worktree.')) {
                        handleWorktreeUpdate(msg);
                    }
                }
            } catch (e) {
                console.error('Error parsing event:', e);
            }
        };

        eventWs.onerror = (err) => {
            console.error('Event WebSocket error:', err);
        };
    }

    function handleEventNotification(event) {
        // Check if this event type is in our notification list
        const eventType = event.type;
        if (!notificationSettings.events.includes(eventType)) return;

        let title = '';
        let body = '';
        let icon = '/static/img/icon.png';

        if (eventType === 'service.crashed') {
            const payload = event.payload || {};
            title = 'Trellis: Service Crashed';
            body = 'Service ' + (payload.service || 'unknown') + ' crashed: ' + (payload.reason || 'unknown error');
        } else if (eventType === 'workflow.finished') {
            const payload = event.payload || {};
            // Check failures_only setting
            if (notificationSettings.failures_only && payload.success) {
                return; // Don't notify on success if failures_only is true
            }
            // Use test-specific messages if test counts are available
            if (payload.tests_total !== undefined) {
                const passed = payload.tests_passed || 0;
                const failed = payload.tests_failed || 0;
                const total = payload.tests_total || 0;
                if (failed > 0) {
                    title = 'Trellis: Tests Failed';
                    body = (payload.name || 'Tests') + ': ' + passed + '/' + total + ' passed, ' + failed + ' failed';
                } else {
                    title = 'Trellis: Tests Passed';
                    body = (payload.name || 'Tests') + ': ' + passed + '/' + total + ' passed';
                }
            } else {
                title = payload.success ? 'Trellis: Workflow Succeeded' : 'Trellis: Workflow Failed';
                body = 'Workflow ' + (payload.name || payload.workflow_id || 'unknown') + (payload.success ? ' completed successfully' : ' failed');
            }
        } else if (eventType === 'trace.completed') {
            const payload = event.payload || {};
            title = 'Trellis: Trace Completed';
            body = 'Trace "' + (payload.name || 'unknown') + '" finished with ' + (payload.total_entries || 0) + ' entries';
        } else if (eventType === 'trace.failed') {
            const payload = event.payload || {};
            title = 'Trellis: Trace Failed';
            body = 'Trace "' + (payload.name || 'unknown') + '" failed: ' + (payload.error || 'unknown error');
        } else if (eventType === 'notify.done') {
            const payload = event.payload || {};
            title = 'Trellis: Done';
            body = payload.message || 'Task completed';
        } else if (eventType === 'notify.blocked') {
            const payload = event.payload || {};
            title = 'Trellis: Blocked';
            body = payload.message || 'Waiting for input';
        } else if (eventType === 'notify.error') {
            const payload = event.payload || {};
            title = 'Trellis: Error';
            body = payload.message || 'An error occurred';
        } else {
            // Generic notification - try to use message field if present
            const payload = event.payload || {};
            title = 'Trellis: ' + eventType;
            body = payload.message || JSON.stringify(payload);
        }

        const notification = new Notification(title, {
            body: body,
            icon: icon,
            image: icon,  // Larger image shown in notification body on supported platforms
            badge: icon   // Badge icon for platforms that support it
        });

        // Play sound if enabled
        if (notificationSettings.sound) {
            try {
                const audio = new Audio('/static/audio/notification.mp3');
                audio.volume = 0.3;
                audio.play().catch(() => {});
            } catch (e) {}
        }

        // Auto-close after 5 seconds
        setTimeout(() => notification.close(), 5000);
    }

    // Initialize notifications on page load
    initNotifications();

    // Connect unified event WebSocket (handles notifications, service status, worktree updates)
    connectEventWebSocket();

    // Handle worktree events by refreshing the picker
    function handleWorktreeUpdate(event) {
        const eventType = event.type;
        if (eventType === 'worktree.created' || eventType === 'worktree.activated') {
            // Refresh the terminal picker to show new sessions
            reloadTerminalPicker();
        }
    }

    // Reload terminal picker from API (full refresh)
    function reloadTerminalPicker() {
        fetch('/api/v1/terminal/sessions')
            .then(r => r.json())
            .then(data => {
                const select = document.getElementById('navSelect');
                const currentVal = $('#navSelect').val();
                select.innerHTML = '';

                // Add terminals first (local terminals should be at the top)
                if (data.data && data.data.sessions) {
                    for (const sess of data.data.sessions) {
                        const isRemote = sess.isRemote || false;
                        const prefix = isRemote ? '!' : '@';
                        const displayName = isRemote ? sess.name : sessionToDisplayName(sess.name);
                        for (const win of (sess.windows || [])) {
                            const opt = document.createElement('option');
                            const worktree = sessionToWorktree(sess.name);
                            let url;
                            if (isRemote) {
                                url = '/terminal/remote/' + win.name;
                            } else {
                                url = '/terminal/local/' + worktree + '/' + win.name;
                            }
                            opt.value = url;
                            opt.dataset.isRemote = isRemote;
                            opt.dataset.isTerminal = true;
                            opt.dataset.session = sess.name;
                            opt.dataset.window = win.name;
                            opt.dataset.worktree = worktree;
                            opt.textContent = isRemote ? prefix + displayName : prefix + displayName + ' - ' + win.name;
                            select.appendChild(opt);
                        }
                        // Add output and editor for local sessions
                        if (!isRemote) {
                            const worktree = sessionToWorktree(sess.name);
                            // Output
                            const outputOpt = document.createElement('option');
                            outputOpt.value = '/terminal/output/' + worktree;
                            outputOpt.dataset.isRemote = false;
                            outputOpt.dataset.isOutput = true;
                            outputOpt.dataset.worktree = worktree;
                            outputOpt.textContent = '@' + displayName + ' - output';
                            select.appendChild(outputOpt);
                            // Editor
                            const editorOpt = document.createElement('option');
                            editorOpt.value = '/terminal/editor/' + worktree;
                            editorOpt.dataset.isRemote = false;
                            editorOpt.dataset.isEditor = true;
                            editorOpt.dataset.worktree = worktree;
                            editorOpt.textContent = '@' + displayName + ' - editor';
                            select.appendChild(editorOpt);
                        }
                    }
                }

                // Add services
                if (initialServices && initialServices.length > 0) {
                    for (const svc of initialServices) {
                        const opt = document.createElement('option');
                        opt.value = '/terminal/service/' + svc.name;
                        opt.dataset.isService = true;
                        opt.dataset.serviceName = svc.name;
                        opt.dataset.serviceStatus = svc.status;
                        opt.textContent = '#' + svc.name + ' - service';
                        select.appendChild(opt);
                    }
                }

                // Add links
                if (initialLinks && initialLinks.length > 0) {
                    for (const link of initialLinks) {
                        const opt = document.createElement('option');
                        opt.value = 'link:' + link.url;
                        opt.dataset.isLink = true;
                        opt.dataset.linkUrl = link.url;
                        opt.dataset.linkWindowName = 'trellis_link_' + link.name.replace(/[^a-zA-Z0-9]/g, '_');
                        opt.textContent = '> ' + link.name;
                        select.appendChild(opt);
                    }
                }

                // Add log viewers
                if (initialLogViewers && initialLogViewers.length > 0) {
                    for (const lv of initialLogViewers) {
                        const opt = document.createElement('option');
                        opt.value = '/terminal/logviewer/' + lv.name;
                        opt.dataset.isLogViewer = true;
                        opt.dataset.logViewerName = lv.name;
                        opt.textContent = '~' + lv.name + ' - logs';
                        select.appendChild(opt);
                    }
                }

                // Add navigation pages at the end
                for (const page of TrellisNav.NAV_PAGES) {
                    const opt = document.createElement('option');
                    opt.value = page.value;
                    opt.dataset.isPage = true;
                    opt.dataset.pageIcon = page.icon;
                    opt.textContent = page.text;
                    select.appendChild(opt);
                }

                // Update originalNavOptions for history picker
                originalNavOptions = Array.from(select.options).map(opt => ({
                    value: opt.value,
                    textContent: opt.textContent,
                    dataset: { ...opt.dataset }
                }));
                // Sync to TrellisNav for shared history picker
                TrellisNav.setOriginalOptions(originalNavOptions);

                // Reinitialize select2
                refreshingPicker = true;
                $('#navSelect').select2('destroy').select2({
                    placeholder: 'Select terminal...',
                    width: '300px',
                    templateResult: formatPickerOption,
                    templateSelection: formatPickerOption
                }).on('select2:select', handleNormalSelection);

                // Restore selection if it still exists
                if (currentVal) {
                    const exists = Array.from(select.options).some(o => o.value === currentVal);
                    if (exists) {
                        $('#navSelect').val(currentVal).trigger('change');
                    }
                }
                refreshingPicker = false;
            });
    }

    function handleServiceStatusUpdate(event) {
        const eventType = event.type;
        const payload = event.payload || {};
        const serviceName = payload.service;

        if (!serviceName) return;

        let newStatus = null;
        if (eventType === 'service.started' || eventType === 'service.restarted') {
            newStatus = 'running';
        } else if (eventType === 'service.stopped') {
            newStatus = 'stopped';
        } else if (eventType === 'service.crashed') {
            newStatus = 'crashed';
        }

        if (newStatus) {
            // Update the picker option
            const select = document.getElementById('navSelect');
            const optionValue = '#' + serviceName;
            for (const opt of select.options) {
                if (opt.value === optionValue) {
                    opt.dataset.serviceStatus = newStatus;
                    break;
                }
            }

            // Force Select2 to re-render by destroying and reinitializing
            // This is needed because Select2 caches option data
            const currentVal = $('#navSelect').val();
            refreshingPicker = true;
            $('#navSelect').select2('destroy').select2({
                placeholder: 'Select terminal...',
                width: '300px',
                templateResult: formatPickerOption,
                templateSelection: formatPickerOption
            }).on('select2:select', handleNormalSelection).val(currentVal).trigger('change');
            refreshingPicker = false;

            // Also update the service wrapper if currently viewing this service
            if (currentServiceName === serviceName) {
                const statusEl = document.getElementById('service-status');
                if (statusEl) {
                    statusEl.textContent = newStatus;
                    statusEl.className = 'service-status ' + newStatus;
                }
            }
        }
    }

    // Start unified event WebSocket (notifications, service status, worktree updates)
    connectEventWebSocket();

    // Track link clicks for navigation history
    TrellisNav.setupLinkHistoryTracking();

    // Convert session name to display name (branch name)
    function sessionToDisplayName(sessName) {
        const projectPrefix = projectName.replace(/\./g, '_');
        if (sessName === projectPrefix) {
            return 'main';
        }
        if (sessName.startsWith(projectPrefix + '-')) {
            return sessName.substring(projectPrefix.length + 1);
        }
        return sessName;
    }

    // Get or create a terminal instance
    function getOrCreateTerminal(terminalKey, isRemote) {
        if (terminals[terminalKey]) {
            return terminals[terminalKey];
        }

        // Create container for this terminal
        const container = document.createElement('div');
        container.id = 'terminal-' + terminalKey.replace(/[^a-zA-Z0-9]/g, '-');
        container.style.height = '100%';
        container.style.width = '100%';
        container.style.display = 'none';
        document.getElementById('terminal').appendChild(container);

        // Create xterm instance with dynamic theme
        const term = new Terminal({
            scrollback: 10000,
            fontSize: 13,
            fontFamily: '"JetBrains Mono", Monaco, monospace',
            theme: getTerminalTheme(),
            cursorBlink: true,
            cursorStyle: 'block',
            convertEol: true,
            allowProposedApi: true,
            // Preserve scrollback when apps clear the screen (ED2 escape sequence)
            // Without this, apps like Claude Code that redraw on resize would lose scrollback
            scrollOnEraseInDisplay: true,
            // These help with selection
            rightClickSelectsWord: true
        });

        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(container);
        // Don't fit here - container is display:none, fit will be called in switchTerminal

        const termData = {
            term: term,
            fitAddon: fitAddon,
            ws: null,
            container: container,
            isRemote: isRemote,
            inputBuffer: []  // Buffer keystrokes during ws reconnection
        };
        terminals[terminalKey] = termData;

        // Track scroll position to restore after eraseInDisplay resets to top
        const viewport = container.querySelector('.xterm-viewport');
        if (viewport) {
            let isRestoring = false;
            let restoreTimeout = null;
            let wasAtBottom = true; // Track if user was at bottom before scroll reset

            viewport.addEventListener('scroll', () => {
                const scrollTop = viewport.scrollTop;
                const scrollHeight = viewport.scrollHeight;
                const clientHeight = viewport.clientHeight;
                const isAtBottom = (scrollHeight - scrollTop <= clientHeight + 10);

                // Debug logging
                if (window.TRELLIS_DEBUG_SCROLL) {
                    const prev = lastScrollState[terminalKey];
                    if (prev && prev.scrollTop > 100 && scrollTop < 10) {
                        console.warn('[SCROLL DEBUG] Scroll jumped to top!', {
                            terminal: terminalKey,
                            from: prev.scrollTop,
                            to: scrollTop,
                            scrollHeight: scrollHeight,
                            wasAtBottom: wasAtBottom,
                            stack: new Error().stack
                        });
                    }
                    lastScrollState[terminalKey] = { scrollTop, scrollHeight };
                }

                // Skip restoration logic if we're in the middle of restoring
                if (isRestoring) return;

                // Track user's scroll position when viewing history
                if (!isAtBottom && scrollTop > 100) {
                    // User is viewing history - save their position
                    userScrollPosition[terminalKey] = { scrollTop, timestamp: Date.now(), wasAtBottom: false };
                    wasAtBottom = false;
                } else if (isAtBottom && scrollTop > 0) {
                    // User is at bottom with content - mark as at bottom
                    userScrollPosition[terminalKey] = { scrollTop, timestamp: Date.now(), wasAtBottom: true };
                    wasAtBottom = true;
                }

                // Detect and fix scroll-to-top events
                const saved = userScrollPosition[terminalKey];
                if (saved && scrollTop < 10 && Date.now() - saved.timestamp < SCROLL_RESTORE_WINDOW) {
                    isRestoring = true;
                    clearTimeout(restoreTimeout);

                    if (saved.wasAtBottom) {
                        // User was at bottom - scroll back to bottom
                        if (window.TRELLIS_DEBUG_SCROLL) {
                            console.log('[SCROLL DEBUG] Auto-scrolling to bottom', { scrollHeight });
                        }
                        requestAnimationFrame(() => {
                            term.scrollToBottom();
                            restoreTimeout = setTimeout(() => { isRestoring = false; }, 100);
                        });
                    } else {
                        // User was viewing history - restore their position
                        if (window.TRELLIS_DEBUG_SCROLL) {
                            console.log('[SCROLL DEBUG] Auto-restoring scroll', { from: scrollTop, to: saved.scrollTop });
                        }
                        viewport.scrollTop = saved.scrollTop;
                        restoreTimeout = setTimeout(() => { isRestoring = false; }, 100);
                    }
                }
            });
        }

        // Register input handler ONCE per terminal (uses termData.ws so it works across reconnects)
        term.onData((data) => {
            // Check for Shift+Enter: if data is carriage return and shift is held, send newline instead
            const actualData = (data === '\r' && window.shiftHeld) ? '\n' : data;

            if (termData.ws && termData.ws.readyState === WebSocket.OPEN) {
                termData.ws.send(JSON.stringify({ type: 'input', data: actualData }));
            } else {
                // Buffer keystrokes during reconnection
                termData.inputBuffer.push(actualData);
            }
        });

        // For remote terminals, add custom selection handling since tmux mouse mode interferes
        if (isRemote) {
            let selectionStart = null;
            let lastSelection = null;

            function getTerminalPosition(e) {
                const screen = container.querySelector('.xterm-screen');
                if (!screen) return { col: 0, row: 0 };
                const rect = screen.getBoundingClientRect();
                const cellWidth = rect.width / term.cols;
                const cellHeight = rect.height / term.rows;
                const col = Math.floor((e.clientX - rect.left) / cellWidth);
                const row = Math.floor((e.clientY - rect.top) / cellHeight);
                return { col: Math.max(0, Math.min(col, term.cols - 1)), row: Math.max(0, Math.min(row, term.rows - 1)) };
            }

            container.addEventListener('mousedown', (e) => {
                if (e.button === 0) {
                    e.preventDefault();
                    e.stopPropagation();
                    selectionStart = getTerminalPosition(e);
                    lastSelection = null;
                    term.clearSelection();
                }
            }, true);

            container.addEventListener('mousemove', (e) => {
                if (selectionStart && e.buttons === 1) {
                    e.preventDefault();
                    e.stopPropagation();
                    const end = getTerminalPosition(e);
                    let startPos = selectionStart;
                    let endPos = end;

                    if (endPos.row < startPos.row || (endPos.row === startPos.row && endPos.col < startPos.col)) {
                        [startPos, endPos] = [endPos, startPos];
                    }

                    if (startPos.row === endPos.row) {
                        const length = endPos.col - startPos.col + 1;
                        term.select(startPos.col, startPos.row, length);
                    } else {
                        term.selectLines(startPos.row, endPos.row);
                    }
                }
            }, true);

            container.addEventListener('mouseup', (e) => {
                if (selectionStart) {
                    e.preventDefault();
                    e.stopPropagation();
                    lastSelection = term.getSelection();
                    selectionStart = null;
                }
            }, true);

            container.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
            }, true);

            termData.getLastSelection = () => lastSelection || term.getSelection();
        } else {
            // Local terminals use default xterm.js selection
            termData.getLastSelection = () => term.getSelection();
        }

        return termData;
    }

    // Connect WebSocket for a terminal
    function connectWebSocket(termData, session, windowName, isRemote) {
        // If already connected and open, nothing to do
        if (termData.ws && termData.ws.readyState === WebSocket.OPEN) {
            return;
        }

        // Close any existing WebSocket before creating new one
        if (termData.ws) {
            try {
                termData.ws.close();
            } catch (e) {}
            termData.ws = null;
        }

        const term = termData.term;
        const fitAddon = termData.fitAddon;
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = wsProtocol + '//' + window.location.host + '/api/v1/terminal/ws?session=' +
            encodeURIComponent(session) + '&window=' + encodeURIComponent(windowName) +
            (isRemote ? '&remote=1' : '');

        const ws = new ReconnectingWebSocket(wsUrl);
        ws.maxReconnectAttempts = 10;
        ws.reconnectInterval = 1000;
        ws.maxReconnectInterval = 30000;
        ws.reconnectDecay = 1.5;
        termData.ws = ws;

        ws.onopen = () => {
            // Wait for fonts to be ready, then fit and send ACCURATE resize
            // Server waits for this resize before sending scrollback
            const doConnectFit = () => {
                fitAddon.fit();
                // Send resize FIRST so server can size tmux before sending scrollback
                ws.send(JSON.stringify({ type: 'resize', rows: term.rows, cols: term.cols }));
                term.write('\r\n\x1b[38;2;86;171;47mConnected to ' + session + ':' + windowName + '\x1b[0m\r\n');
                term.scrollToBottom();
                term.focus();
                // Flush any buffered keystrokes from during reconnection
                if (termData.inputBuffer.length > 0) {
                    const buffered = termData.inputBuffer.join('');
                    termData.inputBuffer = [];
                    ws.send(JSON.stringify({ type: 'input', data: buffered }));
                }
            };

            // Wait for fonts to be ready before fitting and sending resize
            const fitAfterFonts = () => {
                setTimeout(doConnectFit, 50);
            };
            if (document.fonts && document.fonts.ready) {
                document.fonts.ready.then(fitAfterFonts);
            } else {
                fitAfterFonts();
            }
        };

        ws.onmessage = (event) => {
            if (typeof event.data === 'string') {
                let handled = false;
                try {
                    const msg = JSON.parse(event.data);
                    if (msg && typeof msg === 'object' && msg.type === 'output' && msg.data) {
                        term.write(atob(msg.data));
                        handled = true;
                    }
                } catch (e) {}
                if (!handled) {
                    term.write(event.data);
                }
                // Note: scroll position restoration is handled by the scroll event listener
                // which automatically detects and fixes scroll-to-top events
            }
        };

        ws.onerror = (err) => console.error('WebSocket error:', err);

        ws.onclose = (event) => {
            // Don't show "Disconnected" if it was a normal close (session ended message already shown)
            if (event.code !== 1000) {
                term.write('\r\n\x1b[31mDisconnected\x1b[0m\r\n');
            }
        };

        // Input handler is registered once in getOrCreateTerminal, not here
    }

    // Switch to a terminal (hide/show, don't navigate)
    var isSwitchingTerminal = false; // Guard against re-entrancy from Select2 events
    function switchTerminal(terminalKey, isRemote) {
        // Prevent recursive calls (Select2's change.select2 can trigger select2:select)
        if (isSwitchingTerminal) return;

        // Stop service log polling if active
        if (serviceLogPollTimer) {
            clearInterval(serviceLogPollTimer);
            serviceLogPollTimer = null;
        }
        currentServiceName = null;
        currentLinkUrl = null; // Clear link state when switching terminals
        wasInCodeWrapper = false; // Clear code view state when switching terminals

        // Close log viewer websocket if active
        closeLogViewerWs();

        // Parse session/window from key or URL
        // terminalKey can be either:
        //   - Terminal key format: "session/window" (e.g., "trellis/terminal")
        //   - URL format: "/terminal/local/worktree/window" or "/terminal/remote/window"
        let session, windowName;
        if (terminalKey.startsWith('/terminal/')) {
            // URL format - contains worktree name, need to convert to session
            const urlParts = terminalKey.split('/');
            if (isRemote) {
                // /terminal/remote/window -> urlParts = ['', 'terminal', 'remote', 'window']
                windowName = urlParts[3];
                session = windowName;  // Remote session name equals window name
            } else {
                // /terminal/local/worktree/window -> urlParts = ['', 'terminal', 'local', 'worktree', 'window']
                const worktree = urlParts[3];
                windowName = urlParts[4];
                session = worktreeToSession(worktree);  // Convert worktree to session name
            }
            // Normalize terminalKey to session/window format for terminal lookup
            terminalKey = isRemote
                ? session + '/' + windowName + '?remote=1'
                : session + '/' + windowName;
        } else {
            // Terminal key format: "session/window"
            const parts = terminalKey.split('/');
            session = parts[0];
            windowName = parts[1];
        }
        // Remove ?remote=1 suffix if present
        if (windowName && windowName.includes('?')) {
            windowName = windowName.split('?')[0];
        }

        // Save to navigation history (use URL, not terminal key)
        if (currentTerminalKey && currentTerminalKey !== terminalKey) {
            pushToScreenHistory(window.location.pathname);
        }

        // Hide current terminal
        if (currentTerminalKey && terminals[currentTerminalKey]) {
            terminals[currentTerminalKey].container.style.display = 'none';
        }

        // Ensure we're showing terminal view (hide code/workflow/service/logviewer views)
        document.getElementById('terminal-wrapper').style.display = 'block';
        document.getElementById('code-wrapper').style.display = 'none';
        if (document.getElementById('workflow-wrapper')) {
            document.getElementById('workflow-wrapper').style.display = 'none';
        }
        if (document.getElementById('service-wrapper')) {
            document.getElementById('service-wrapper').style.display = 'none';
        }
        if (document.getElementById('logviewer-wrapper')) {
            document.getElementById('logviewer-wrapper').style.display = 'none';
        }
        if (document.getElementById('showTerminalBtn')) {
            document.getElementById('showTerminalBtn').classList.add('active');
            document.getElementById('showCodeBtn').classList.remove('active');
        }

        // Get or create the new terminal
        const termData = getOrCreateTerminal(terminalKey, isRemote);
        currentTerminalKey = terminalKey;

        // Update page title
        document.title = (isRemote ? 'Remote: ' : 'Terminal: ') + windowName;

        // Show the terminal
        termData.container.style.display = 'block';

        // Connect WebSocket if not connected (do this before fit so resize can be sent)
        if (!termData.ws || termData.ws.readyState !== WebSocket.OPEN) {
            connectWebSocket(termData, session, windowName, isRemote);
        }

        // Fit after display change and send resize
        // Use multiple fit calls to handle race conditions with CSS/fonts loading
        const doFit = () => {
            termData.fitAddon.fit();
            termData.term.scrollToBottom();
            termData.term.focus();

            // Send resize to server (important for proper terminal sizing)
            if (termData.ws && termData.ws.readyState === WebSocket.OPEN) {
                termData.ws.send(JSON.stringify({
                    type: 'resize',
                    rows: termData.term.rows,
                    cols: termData.term.cols
                }));
            }
        };

        // Wait for fonts to be ready before fitting (fixes narrow terminal on initial load)
        // Note: even after fonts.ready, xterm.js needs time to measure the font
        const fitWhenReady = () => {
            // Use setTimeout instead of rAF to give xterm.js time to measure fonts
            setTimeout(() => {
                doFit();
                // Second fit after a short delay to catch any late layout changes
                setTimeout(doFit, 100);
            }, 50);
        };

        if (document.fonts && document.fonts.ready) {
            document.fonts.ready.then(fitWhenReady);
        } else {
            // Fallback for browsers without font loading API
            fitWhenReady();
        }

        // Update URL without navigating (for bookmarking/refresh)
        const worktree = sessionToWorktree(session);
        currentWorktree = worktree;
        const newUrl = isRemote
            ? '/terminal/remote/' + windowName
            : '/terminal/local/' + worktree + '/' + windowName;
        history.pushState({ type: isRemote ? 'remote' : 'local', worktree, window: windowName }, '', newUrl);

        // Update terminal picker to match (use URL, not terminal key)
        // Set guard to prevent Select2 from triggering another switchTerminal call
        isSwitchingTerminal = true;
        $('#navSelect').val(newUrl).trigger('change.select2');
        isSwitchingTerminal = false;

        // Update workflow selector visibility
        const workflowSelect = document.getElementById('workflowSelect');
        if (workflowSelect) {
            workflowSelect.style.display = isRemote ? 'none' : 'inline-block';
        }
        const showCodeBtn = document.getElementById('showCodeBtn');
        if (showCodeBtn) {
            showCodeBtn.style.display = isRemote ? 'none' : 'inline-block';
        }
    }

    // Handle window resize - debounced to avoid excessive resize messages
    // Note: tmux sessions have scroll-on-clear=off set, which preserves scrollback
    // even when apps like Claude Code clear/redraw the screen on resize
    let resizeTimeout = null;
    let lastSentSize = { rows: 0, cols: 0 };
    window.addEventListener('resize', () => {
        // Only resize the currently active terminal
        if (!currentTerminalKey || !terminals[currentTerminalKey]) return;

        const termData = terminals[currentTerminalKey];

        // Clear any pending resize
        clearTimeout(resizeTimeout);

        // Fit the terminal to the new window size
        termData.fitAddon.fit();

        // Debounce server notification (wait for resize to settle)
        resizeTimeout = setTimeout(() => {
            if (termData.ws && termData.ws.readyState === WebSocket.OPEN) {
                const { rows, cols } = termData.term;
                // Only send if size actually changed
                if (rows !== lastSentSize.rows || cols !== lastSentSize.cols) {
                    termData.ws.send(JSON.stringify({ type: 'resize', rows, cols }));
                    lastSentSize = { rows, cols };
                }
            }
        }, 150);
    });

    // Function to manually sync terminal size with server (use when you need apps to know the new size)
    window.syncTerminalSize = function() {
        if (!currentTerminalKey || !terminals[currentTerminalKey]) return;
        const termData = terminals[currentTerminalKey];
        if (termData.ws && termData.ws.readyState === WebSocket.OPEN) {
            termData.ws.send(JSON.stringify({
                type: 'resize',
                rows: termData.term.rows,
                cols: termData.term.cols
            }));
        }
    };

    // Track initialization state - need both API data and window load complete
    let apiDataReady = false;
    let windowLoaded = document.readyState === 'complete';
    let apiData = null;

    function initializeTerminalWhenReady() {
        if (!apiDataReady || !windowLoaded) return;
        doTerminalInit(apiData);
    }

    if (!windowLoaded) {
        window.addEventListener('load', () => {
            windowLoaded = true;
            initializeTerminalWhenReady();
        });
    }

    // Load terminal list and set up selector
    fetch('/api/v1/terminal/sessions')
        .then(r => r.json())
        .then(data => {
            apiData = data;
            apiDataReady = true;
            initializeTerminalWhenReady();
        });

    function doTerminalInit(data) {
            const select = document.getElementById('navSelect');
            select.innerHTML = '';

            // Add terminals first (local terminals should be at the top)
            if (data.data && data.data.sessions) {
                for (const sess of data.data.sessions) {
                    const isRemote = sess.isRemote || false;
                    const prefix = isRemote ? '!' : '@';
                    const displayName = isRemote ? sess.name : sessionToDisplayName(sess.name);
                    for (const win of (sess.windows || [])) {
                        const opt = document.createElement('option');
                        // Use URL as value for history consistency
                        const worktree = sessionToWorktree(sess.name);
                        let url;
                        if (isRemote) {
                            url = '/terminal/remote/' + win.name;
                        } else {
                            url = '/terminal/local/' + worktree + '/' + win.name;
                        }
                        opt.value = url;
                        opt.dataset.isRemote = isRemote;
                        opt.dataset.isTerminal = true;
                        opt.dataset.session = sess.name;
                        opt.dataset.window = win.name;
                        opt.dataset.worktree = worktree;
                        opt.textContent = isRemote ? prefix + displayName : prefix + displayName + ' - ' + win.name;
                        if (sess.name === initialSession && win.name === initialWindow) {
                            opt.selected = true;
                        }
                        select.appendChild(opt);
                    }
                    // Add "output" pseudo-terminal for local sessions (workflow output)
                    if (!isRemote) {
                        const outputOpt = document.createElement('option');
                        const worktree = sessionToWorktree(sess.name);
                        outputOpt.value = '/terminal/output/' + worktree;
                        outputOpt.dataset.isRemote = false;
                        outputOpt.dataset.isOutput = true;
                        outputOpt.dataset.worktree = worktree;
                        outputOpt.textContent = '@' + displayName + ' - output';
                        select.appendChild(outputOpt);

                        // Add "editor" option for local sessions (VS Code)
                        const editorOpt = document.createElement('option');
                        editorOpt.value = '/terminal/editor/' + worktree;
                        editorOpt.dataset.isRemote = false;
                        editorOpt.dataset.isEditor = true;
                        editorOpt.dataset.worktree = worktree;
                        editorOpt.textContent = '@' + displayName + ' - editor';
                        select.appendChild(editorOpt);
                    }
                }
            }

            // Add services to the picker with '#' prefix (using URL values)
            if (initialServices && initialServices.length > 0) {
                for (const svc of initialServices) {
                    const opt = document.createElement('option');
                    opt.value = '/terminal/service/' + svc.name;
                    opt.dataset.isService = true;
                    opt.dataset.serviceName = svc.name;
                    opt.dataset.serviceStatus = svc.status;
                    opt.textContent = '#' + svc.name + ' - service';
                    select.appendChild(opt);
                }
            }

            // Add links to the picker with '>' prefix
            if (initialLinks && initialLinks.length > 0) {
                for (const link of initialLinks) {
                    const opt = document.createElement('option');
                    opt.value = 'link:' + link.url;
                    opt.dataset.isLink = true;
                    opt.dataset.linkUrl = link.url;
                    // Create a stable window name from the link name (for tab reuse)
                    opt.dataset.linkWindowName = 'trellis_link_' + link.name.replace(/[^a-zA-Z0-9]/g, '_');
                    opt.textContent = '> ' + link.name;
                    select.appendChild(opt);
                }
            }

            // Add log viewers to the picker with '~' prefix (using URL values)
            if (initialLogViewers && initialLogViewers.length > 0) {
                for (const lv of initialLogViewers) {
                    const opt = document.createElement('option');
                    opt.value = '/terminal/logviewer/' + lv.name;
                    opt.dataset.isLogViewer = true;
                    opt.dataset.logViewerName = lv.name;
                    opt.textContent = '~' + lv.name + ' - logs';
                    select.appendChild(opt);
                }
            }

            // Add navigation pages at the end with '/' prefix
            for (const page of TrellisNav.NAV_PAGES) {
                const opt = document.createElement('option');
                opt.value = page.value;
                opt.dataset.isPage = true;
                opt.dataset.pageIcon = page.icon;
                opt.textContent = page.text;
                select.appendChild(opt);
            }

            // Store original options for restoring after history mode
            originalNavOptions = Array.from(select.options).map(opt => ({
                value: opt.value,
                textContent: opt.textContent,
                dataset: { ...opt.dataset }
            }));
            // Sync to TrellisNav for shared history picker
            TrellisNav.setOriginalOptions(originalNavOptions);
            TrellisNav.setRefreshPicker(refreshTerminalPicker);

            $('#navSelect').select2({
                placeholder: 'Select terminal...',
                width: '300px',
                templateResult: formatPickerOption,
                templateSelection: formatPickerOption
            }).on('select2:select', handleNormalSelection);

            // Wait for select2 to fully render before initializing terminal
            // This ensures navbar has final height for correct terminal sizing
            requestAnimationFrame(() => {
                setTimeout(() => {
                    // Initialize based on view type
                    if (initialViewType === 'service' && initialServiceName) {
                        showService(initialServiceName);
                    } else if (initialViewType === 'logviewer' && initialLogViewerName) {
                        showLogViewer(initialLogViewerName);
                    } else if (initialViewType === 'editor') {
                        showCode();
                    } else if (initialViewType === 'output' && initialWorktree) {
                        showOutput(initialWorktree);
                    } else if (initialViewType === 'remote' && initialWindow) {
                        // For remote windows, session name equals window name
                        const remoteKey = initialWindow + '/' + initialWindow + '?remote=1';
                        switchTerminal(remoteKey, true);
                    } else if (initialSession && initialWindow) {
                        const initialKey = initialSession + '/' + initialWindow;
                        switchTerminal(initialKey, false);
                    }
                }, 50);
            });
    }

    // Handle browser back/forward navigation
    window.addEventListener('popstate', (event) => {
        if (event.state) {
            if (event.state.type === 'service' && event.state.service) {
                showService(event.state.service);
            } else if (event.state.type === 'logviewer' && event.state.name) {
                showLogViewer(event.state.name);
            } else if (event.state.type === 'editor' && event.state.worktree) {
                currentWorktree = event.state.worktree;
                showCode();
            } else if (event.state.type === 'output' && event.state.worktree) {
                showOutput(event.state.worktree);
            } else if (event.state.type === 'remote' && event.state.window) {
                // For remote windows, session name equals window name
                const remoteKey = event.state.window + '/' + event.state.window + '?remote=1';
                switchTerminal(remoteKey, true);
            } else if (event.state.type === 'local' && event.state.worktree && event.state.window) {
                const session = worktreeToSession(event.state.worktree);
                const localKey = session + '/' + event.state.window;
                currentWorktree = event.state.worktree;
                switchTerminal(localKey, false);
            }
        }
    });

    // Store workflow configurations for inputs access
    let workflowConfigs = {};

    // Load workflow list for selector
    fetch('/api/v1/workflows')
        .then(r => r.json())
        .then(data => {
            const select = document.getElementById('workflowSelect');
            if (select && data.data && Array.isArray(data.data)) {
                data.data.sort((a, b) => (a.Name || '').localeCompare(b.Name || ''));
                for (const wf of data.data) {
                    if (wf.ID && wf.ID.startsWith('_')) continue;
                    // Store full workflow config
                    workflowConfigs[wf.ID] = wf;
                    const opt = document.createElement('option');
                    opt.value = wf.ID;
                    opt.textContent = wf.Name;
                    // Store workflow config as data attributes
                    opt.dataset.confirm = wf.Confirm || false;
                    opt.dataset.confirmMessage = wf.ConfirmMessage || '';
                    opt.dataset.restartServices = wf.RestartServices || false;
                    opt.dataset.hasInputs = (wf.Inputs && wf.Inputs.length > 0) ? 'true' : 'false';
                    select.appendChild(opt);
                }
            }
        });

    const workflowSelect = document.getElementById('workflowSelect');
    if (workflowSelect) {
        workflowSelect.addEventListener('change', function() {
            if (this.value) {
                const selectedOption = this.options[this.selectedIndex];
                const confirm = selectedOption.dataset.confirm === 'true';
                const confirmMessage = selectedOption.dataset.confirmMessage || '';
                const restartServices = selectedOption.dataset.restartServices === 'true';
                const hasInputs = selectedOption.dataset.hasInputs === 'true';
                const wfConfig = workflowConfigs[this.value];
                runWorkflow(this.value, confirm, confirmMessage, restartServices, hasInputs ? wfConfig : null);
                this.value = '';
            }
        });
    }

    // Track if Shift is held for Shift+Enter handling
    window.shiftHeld = false;

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        // Track shift key state
        if (e.shiftKey) {
            window.shiftHeld = true;
        }

        // Cmd+C (Mac) or Ctrl+Shift+C (others) to copy terminal selection
        if ((e.metaKey && e.key === 'c') || (e.ctrlKey && e.shiftKey && e.key === 'C')) {
            const termData = terminals[currentTerminalKey];
            if (termData) {
                // Try getLastSelection first (for shift+drag selection), then term.getSelection()
                const selection = termData.getLastSelection ? termData.getLastSelection() : termData.term.getSelection();
                if (selection) {
                    e.preventDefault();
                    navigator.clipboard.writeText(selection).then(() => {
                        console.log('Copied', selection.length, 'chars to clipboard');
                    }).catch(err => {
                        console.error('Clipboard write failed:', err);
                    });
                    return;
                }
            }
        }

        // Cmd+V (Mac) or Ctrl+Shift+V (others) to paste into terminal
        // But only if not focused on an input field or modal is not open
        if ((e.metaKey && e.key === 'v') || (e.ctrlKey && e.shiftKey && e.key === 'V')) {
            // Check if we're in an input field or a modal is open
            const activeEl = document.activeElement;
            const isInInput = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'SELECT' || activeEl.isContentEditable);
            const modalOpen = document.querySelector('.modal.show') !== null;

            if (isInInput || modalOpen) {
                // Let the default paste behavior work for inputs/modals
                return;
            }

            e.preventDefault();
            navigator.clipboard.readText().then(text => {
                const termData = terminals[currentTerminalKey];
                if (termData && termData.ws && termData.ws.readyState === WebSocket.OPEN) {
                    termData.ws.send(JSON.stringify({ type: 'input', data: text }));
                }
            });
            return;
        }

        // Escape to close various panels
        if (e.key === 'Escape') {
            // Close log viewer expanded detail panel
            const logViewerExpanded = document.getElementById('logviewer-expanded');
            if (logViewerExpanded && logViewerExpanded.style.display !== 'none') {
                e.preventDefault();
                closeLogViewerExpanded();
                return;
            }
            // Close service log expanded detail panel
            const serviceExpanded = document.getElementById('service-expanded');
            if (serviceExpanded && serviceExpanded.style.display !== 'none') {
                e.preventDefault();
                closeServiceExpanded();
                return;
            }
            // Close workflow output
            const workflowWrapper = document.getElementById('workflow-wrapper');
            if (workflowWrapper && workflowWrapper.style.display !== 'none') {
                e.preventDefault();
                showTerminal();
                return;
            }
        }
        // Cmd/Ctrl+P to open picker (but not Ctrl+P on non-Mac which should go to terminal)
        if (e.metaKey && e.key === 'p') {
            e.preventDefault();
            const currentPath = window.location.pathname;
            // Set value first so Select2 knows what's selected, then open
            $('#navSelect').val(currentPath).trigger('change.select2');
            $('#navSelect').select2('open');
        }
        // Cmd/Ctrl+/ to open workflow picker (local terminals only)
        if ((e.metaKey || e.ctrlKey) && e.key === '/') {
            e.preventDefault();
            const wfSelect = document.getElementById('workflowSelect');
            if (wfSelect && wfSelect.style.display !== 'none') {
                wfSelect.focus();
                wfSelect.showPicker?.() || wfSelect.click();
            }
        }
        // Cmd/Ctrl+E to toggle code/terminal (not available for remote windows or log viewers)
        if ((e.metaKey || e.ctrlKey) && e.key === 'e') {
            // Skip for remote windows - VS Code can't edit remote files via Trellis
            if (window.location.pathname.startsWith('/terminal/remote/')) {
                return;
            }
            // Skip for log viewers - no code view available
            if (currentLogViewerName) {
                return;
            }
            e.preventDefault();
            if (document.getElementById('code-wrapper').style.display === 'none') {
                showCode();
            } else {
                showTerminal();
            }
        }
        // Cmd/Ctrl+Backspace to open history picker
        if ((e.metaKey || e.ctrlKey) && e.key === 'Backspace') {
            e.preventDefault();
            // Open history picker (works from any view)
            TrellisNav.openHistoryPicker();
        }
        // Cmd/Ctrl+H to show help
        if ((e.metaKey || e.ctrlKey) && e.key === 'h') {
            e.preventDefault();
            const modal = new bootstrap.Modal(document.getElementById('shortcutHelpModal'));
            modal.show();
        }

        // Check custom shortcuts for any other keys
        handleCustomShortcut(e);
    }, true); // Capture phase so our shortcuts run before xterm.js

    // Reset shift state on keyup
    document.addEventListener('keyup', (e) => {
        if (!e.shiftKey) {
            window.shiftHeld = false;
        }
    });

    // Reset shift state when window loses focus (prevents sticky shift if released while unfocused)
    window.addEventListener('blur', () => {
        window.shiftHeld = false;
    });
    document.addEventListener('visibilitychange', () => {
        if (document.hidden) {
            window.shiftHeld = false;
        }
    });

    // Parse a key string like "cmd+l" or "ctrl+shift+1" into components
    function parseKeyCombo(keyStr) {
        const parts = keyStr.toLowerCase().split('+');
        return {
            meta: parts.includes('cmd') || parts.includes('meta'),
            ctrl: parts.includes('ctrl'),
            shift: parts.includes('shift'),
            alt: parts.includes('alt') || parts.includes('option'),
            key: parts[parts.length - 1]
        };
    }

    // Check if a keyboard event matches a key combo
    function matchesKeyCombo(e, combo) {
        // For meta/ctrl, check if either metaKey or ctrlKey matches if either is required
        const metaOrCtrl = (combo.meta || combo.ctrl) ? (e.metaKey || e.ctrlKey) : (!e.metaKey && !e.ctrlKey);
        const shiftMatch = combo.shift ? e.shiftKey : !e.shiftKey;
        const altMatch = combo.alt ? e.altKey : !e.altKey;
        const keyMatch = e.key.toLowerCase() === combo.key;
        return metaOrCtrl && shiftMatch && altMatch && keyMatch;
    }

    // Handle custom shortcuts, returns true if a shortcut was handled
    // Window must start with a prefix character indicating the target type:
    //   ~name           = log viewer (e.g., ~nginx)
    //   #name           = service (e.g., #api)
    //   @worktree - win = local terminal (e.g., @main - dev)
    //   !name           = remote window (e.g., !admin)
    function handleCustomShortcut(e) {
        for (const shortcut of customShortcuts) {
            const combo = parseKeyCombo(shortcut.key);
            if (matchesKeyCombo(e, combo)) {
                e.preventDefault();

                const windowSpec = shortcut.window;
                const select = document.getElementById('navSelect');

                // Parse prefix-based shortcuts
                if (windowSpec.startsWith('~')) {
                    // Log viewer shortcut: ~name
                    const logViewerName = windowSpec.substring(1);
                    showLogViewer(logViewerName);
                    $('#navSelect').val(windowSpec).trigger('change.select2');
                    return true;
                } else if (windowSpec.startsWith('#')) {
                    // Service shortcut: #name
                    const serviceName = windowSpec.substring(1);
                    showService(serviceName);
                    $('#navSelect').val(windowSpec).trigger('change.select2');
                    return true;
                } else if (windowSpec.startsWith('@')) {
                    // Local terminal shortcut: @worktree - window
                    const spec = windowSpec.substring(1);
                    const dashIdx = spec.indexOf(' - ');
                    if (dashIdx === -1) {
                        console.warn('Invalid shortcut format: expected @worktree - window, got', windowSpec);
                        return true;
                    }
                    const targetWorktree = spec.substring(0, dashIdx);
                    const targetWindow = spec.substring(dashIdx + 3);

                    // Find matching local terminal option
                    for (const opt of select.options) {
                        if (opt.dataset.isRemote === 'true') continue;
                        if (opt.dataset.isService === 'true') continue;
                        if (opt.dataset.isLogViewer === 'true') continue;
                        if (opt.dataset.isOutput === 'true') continue;
                        if (opt.dataset.isEditor === 'true') continue;

                        // Match worktree and window name
                        if (opt.dataset.worktree === targetWorktree && opt.dataset.window === targetWindow) {
                            switchTerminal(opt.value, false);
                            $('#navSelect').val(opt.value).trigger('change.select2');
                            return true;
                        }
                    }
                    console.warn('No matching terminal found for shortcut:', windowSpec);
                    return true;
                } else if (windowSpec.startsWith('!')) {
                    // Remote window shortcut: !name
                    const remoteName = windowSpec.substring(1);
                    for (const opt of select.options) {
                        if (opt.dataset.isRemote === 'true' && opt.dataset.window === remoteName) {
                            switchTerminal(opt.value, true);
                            $('#navSelect').val(opt.value).trigger('change.select2');
                            return true;
                        }
                    }
                    console.warn('No matching remote window found for shortcut:', windowSpec);
                    return true;
                } else {
                    console.warn('Invalid shortcut: window must start with ~, #, @, or !:', windowSpec);
                    return true;
                }
            }
        }
        return false;
    }

    let codeLoaded = false;
    let codeServerReady = false; // True when code-server is actually ready to receive commands
    let codeLoadedForWorktree = null; // Track which worktree the editor was loaded for
    let codeServerUrl = null;  // Cache the code-server URL
    let wasInCodeWrapper = false; // Track if we just came from code wrapper
    let pendingCodeServerCallbacks = []; // Callbacks waiting for code-server to be ready

    // Install escape hotkey in iframe to allow returning focus to Trellis
    // Returns true if installed successfully, false if cross-origin or other error
    function installEscapeHotkey(iframe) {
        const win = iframe.contentWindow;
        if (!win) {
            console.log('installEscapeHotkey: no contentWindow');
            return false;
        }

        try {
            // Avoid double-install (this will throw for cross-origin)
            if (win.__trellisEscapeInstalled) {
                console.log('installEscapeHotkey: already installed');
                return true;
            }
            win.__trellisEscapeInstalled = true;

            win.addEventListener('keydown', (e) => {
                // Ctrl+Escape to exit iframe and return to Trellis
                if (e.ctrlKey && !e.shiftKey && !e.altKey && e.key === 'Escape') {
                    e.preventDefault();
                    e.stopPropagation();
                    win.parent.postMessage({ type: 'trellis.focusParent' }, '*');
                }
            }, true); // capture phase is important

            console.log('installEscapeHotkey: installed successfully');
            return true;
        } catch (e) {
            // Cross-origin iframes will throw SecurityError
            console.log('installEscapeHotkey: failed (likely cross-origin)', e.message);
            return false;
        }
    }

    // Listen for focus messages from code-server iframe
    window.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'trellis.focusParent') {
            // Switch back to terminal view
            showTerminal();
        }
    });

    function showTerminal() {
        // Stop service log polling if active
        if (serviceLogPollTimer) {
            clearInterval(serviceLogPollTimer);
            serviceLogPollTimer = null;
        }
        currentServiceName = null;

        // Close log viewer websocket if active
        closeLogViewerWs();

        // Track if we're coming from code/link view (for Cmd+Backspace)
        const codeWrapper = document.getElementById('code-wrapper');
        if (codeWrapper && codeWrapper.style.display !== 'none') {
            wasInCodeWrapper = true;
        }

        // If coming from output/service/logviewer view, restore previous terminal
        const prevKey = getPreviousScreenKey();
        if (currentTerminalKey && (currentTerminalKey.startsWith('output:') || currentTerminalKey.startsWith('#') || currentTerminalKey.startsWith('~')) && prevKey) {
            const select = document.getElementById('navSelect');
            const opt = Array.from(select.options).find(o => o.value === prevKey);
            if (opt) {
                const isRemote = opt.dataset.isRemote === 'true';
                switchTerminal(prevKey, isRemote);
                return;
            }
        }

        // If coming from editor view, restore previous terminal key
        if (currentTerminalKey && currentTerminalKey.startsWith('editor:') && terminalKeyBeforeEditor) {
            const restoredKey = terminalKeyBeforeEditor;
            terminalKeyBeforeEditor = null;

            // If previous view was output, go back to output view
            if (restoredKey.startsWith('output:')) {
                const worktree = restoredKey.substring('output:'.length);
                showOutput(worktree);
                return;
            }

            // If previous view was a log viewer, go back to it
            if (restoredKey.startsWith('~')) {
                const logViewerName = restoredKey.substring(1);
                showLogViewer(logViewerName);
                return;
            }

            // If previous view was a service, go back to it
            if (restoredKey.startsWith('#')) {
                const serviceName = restoredKey.substring(1);
                showService(serviceName);
                return;
            }

            currentTerminalKey = restoredKey;
        }

        document.getElementById('terminal-wrapper').style.display = 'block';
        codeWrapper.style.display = 'none';
        if (document.getElementById('workflow-wrapper')) {
            document.getElementById('workflow-wrapper').style.display = 'none';
        }
        if (document.getElementById('service-wrapper')) {
            document.getElementById('service-wrapper').style.display = 'none';
        }
        if (document.getElementById('logviewer-wrapper')) {
            document.getElementById('logviewer-wrapper').style.display = 'none';
        }
        if (document.getElementById('showTerminalBtn')) {
            document.getElementById('showTerminalBtn').classList.add('active');
            document.getElementById('showCodeBtn').classList.remove('active');
        }

        // Update URL and picker to reflect current terminal
        if (currentTerminalKey && !currentTerminalKey.startsWith('#') && !currentTerminalKey.startsWith('~') && !currentTerminalKey.startsWith('output:') && !currentTerminalKey.startsWith('editor:')) {
            const parts = currentTerminalKey.split('/');
            const session = parts[0];
            const windowName = parts[1]?.split('?')[0];
            const isRemote = currentTerminalKey.includes('?remote=1');
            const worktree = sessionToWorktree(session);
            const newUrl = isRemote
                ? '/terminal/remote/' + windowName
                : '/terminal/local/' + worktree + '/' + windowName;
            history.pushState({ type: isRemote ? 'remote' : 'local', worktree, window: windowName }, '', newUrl);
            // Update picker to show current terminal
            $('#navSelect').val(newUrl).trigger('change.select2');
        }

        // Restore page title from current terminal
        if (currentTerminalKey && !currentTerminalKey.startsWith('output:') && !currentTerminalKey.startsWith('editor:')) {
            const parts = currentTerminalKey.split('/');
            const windowName = (parts[1] || '').split('?')[0];
            const isRemote = currentTerminalKey.includes('?remote=1');
            document.title = (isRemote ? 'Remote: ' : 'Terminal: ') + windowName;
        }

        setTimeout(() => {
            if (currentTerminalKey && terminals[currentTerminalKey]) {
                terminals[currentTerminalKey].fitAddon.fit();
                terminals[currentTerminalKey].term.focus();
            }
        }, 100);
    }

    function getCurrentSession() {
        return worktreeToSession(currentWorktree);
    }

    let previousView = null; // Track previous view for Cmd+Backspace ('output', 'terminal', 'service')
    let terminalKeyBeforeEditor = null; // Save terminal key when entering editor
    const linkWindows = {}; // Store references to opened link windows for reuse

    function showCode() {
        // Save to navigation history (use URL) before switching
        const editorKey = 'editor:' + currentWorktree;
        if (currentTerminalKey && currentTerminalKey !== editorKey) {
            pushToScreenHistory(window.location.pathname);
            // Save the terminal key so we can restore it when exiting editor
            terminalKeyBeforeEditor = currentTerminalKey;
        }

        // Remember what view we're coming from
        if (document.getElementById('workflow-wrapper') &&
            document.getElementById('workflow-wrapper').style.display !== 'none') {
            previousView = 'output';
        } else if (document.getElementById('service-wrapper') &&
            document.getElementById('service-wrapper').style.display !== 'none') {
            previousView = 'service';
        } else {
            previousView = 'terminal';
        }

        currentTerminalKey = editorKey;
        document.title = 'Editor';

        document.getElementById('terminal-wrapper').style.display = 'none';
        document.getElementById('code-wrapper').style.display = 'block';
        if (document.getElementById('workflow-wrapper')) {
            document.getElementById('workflow-wrapper').style.display = 'none';
        }
        if (document.getElementById('service-wrapper')) {
            document.getElementById('service-wrapper').style.display = 'none';
        }
        if (document.getElementById('logviewer-wrapper')) {
            document.getElementById('logviewer-wrapper').style.display = 'none';
        }
        if (document.getElementById('showTerminalBtn')) {
            document.getElementById('showTerminalBtn').classList.remove('active');
        }
        if (document.getElementById('showCodeBtn')) {
            document.getElementById('showCodeBtn').classList.add('active');
        }

        // Update picker to show editor URL
        const editorUrl = '/terminal/editor/' + currentWorktree;
        $('#navSelect').val(editorUrl).trigger('change.select2');

        const iframe = document.getElementById('code-iframe');

        // Load VS Code iframe on first show, or reload if worktree changed
        const needsReload = !codeLoaded || codeLoadedForWorktree !== currentWorktree;
        // Use worktreeToSession to get proper session name (not getCurrentSession which uses currentTerminalKey)
        const sessionName = worktreeToSession(currentWorktree);
        if (needsReload) {
            // Mark as not ready while loading
            codeServerReady = false;

            // Force full reload by clearing src first (code-server doesn't reload properly otherwise)
            iframe.src = 'about:blank';
            codeServerUrl = '/vscode/?session=' + encodeURIComponent(sessionName);
            // Use setTimeout to ensure blank page is loaded before setting new src
            setTimeout(() => {
                iframe.src = codeServerUrl;
            }, 50);
            codeLoaded = true;
            codeLoadedForWorktree = currentWorktree;

            // Install escape hotkey once iframe loads and mark as ready
            iframe.addEventListener('load', () => {
                // Wait a bit for code-server to initialize, then mark ready and call pending callbacks
                setTimeout(() => {
                    installEscapeHotkey(iframe);
                    codeServerReady = true;
                    // Call any pending callbacks
                    const callbacks = pendingCodeServerCallbacks;
                    pendingCodeServerCallbacks = [];
                    callbacks.forEach(cb => cb());
                }, 1500);
            }, { once: true });
        }

        // Focus the iframe so keyboard input goes to the editor (with delay for display change)
        setTimeout(() => iframe.focus(), 100);

        // Update URL without navigating (for bookmarking/refresh)
        history.pushState({ type: 'editor', worktree: currentWorktree }, '', editorUrl);
    }

    function showHelp() {
        const modal = new bootstrap.Modal(document.getElementById('shortcutHelpModal'));
        modal.show();
    }

    function showWorkflowOutput(title, worktree) {
        // If no worktree specified, use current
        if (!worktree) {
            worktree = currentWorktree;
        }

        // Save to navigation history before switching to output (use URL)
        if (currentTerminalKey && !currentTerminalKey.startsWith('output:')) {
            pushToScreenHistory(window.location.pathname);
        }

        document.getElementById('terminal-wrapper').style.display = 'none';
        document.getElementById('code-wrapper').style.display = 'none';
        document.getElementById('service-wrapper').style.display = 'none';
        document.getElementById('workflow-wrapper').style.display = 'block';
        document.getElementById('workflow-title').innerHTML = '<i class="fa-solid fa-bolt"></i> ' + title;
        if (document.getElementById('showTerminalBtn')) {
            document.getElementById('showTerminalBtn').classList.remove('active');
            document.getElementById('showCodeBtn').classList.remove('active');
        }

        // Stop service polling if active
        if (serviceLogPollTimer) {
            clearInterval(serviceLogPollTimer);
            serviceLogPollTimer = null;
        }

        // Hide current terminal container
        if (currentTerminalKey && terminals[currentTerminalKey]) {
            terminals[currentTerminalKey].container.style.display = 'none';
        }

        // Update picker to show output is selected
        const outputKey = 'output:' + worktree;
        const outputUrl = '/terminal/output/' + worktree;
        currentTerminalKey = outputKey;
        currentWorktree = worktree;
        $('#navSelect').val(outputUrl).trigger('change.select2');

        // Update URL
        history.pushState({ type: 'output', worktree: worktree }, '', outputUrl);
    }

    function showOutput(worktree) {
        // If no worktree specified, use current
        if (!worktree) {
            worktree = currentWorktree;
        }

        // Save to navigation history before switching to output (use URL)
        if (currentTerminalKey && !currentTerminalKey.startsWith('output:')) {
            pushToScreenHistory(window.location.pathname);
        }

        // Hide current terminal container
        if (currentTerminalKey && terminals[currentTerminalKey]) {
            terminals[currentTerminalKey].container.style.display = 'none';
        }

        document.getElementById('terminal-wrapper').style.display = 'none';
        document.getElementById('code-wrapper').style.display = 'none';
        document.getElementById('workflow-wrapper').style.display = 'block';
        if (document.getElementById('showTerminalBtn')) {
            document.getElementById('showTerminalBtn').classList.remove('active');
            document.getElementById('showCodeBtn').classList.remove('active');
        }

        // Load workflow output for this worktree
        const outputData = workflowOutputs[worktree];
        const titleEl = document.getElementById('workflow-title');
        const outputEl = document.querySelector('#workflow-output code');
        if (outputData) {
            titleEl.innerHTML = '<i class="fa-solid fa-bolt"></i> ' + outputData.title;
            if (outputData.html) {
                outputEl.innerHTML = outputData.html;
            } else {
                outputEl.textContent = outputData.text || '';
            }
        } else {
            titleEl.innerHTML = '<i class="fa-solid fa-bolt"></i> Workflow Output';
            outputEl.textContent = 'No workflow output yet. Run a workflow to see results here.';
        }

        const outputKey = 'output:' + worktree;
        const outputUrl = '/terminal/output/' + worktree;
        currentTerminalKey = outputKey;
        currentWorktree = worktree;
        document.title = 'Output';

        // Update picker (use URL)
        $('#navSelect').val(outputUrl).trigger('change.select2');

        // Update URL
        history.pushState({ type: 'output', worktree: worktree }, '', outputUrl);
    }

    function formatDuration(nanoseconds) {
        if (!nanoseconds) return '0s';
        const ms = nanoseconds / 1000000;
        if (ms < 1000) return ms.toFixed(0) + 'ms';
        const sec = ms / 1000;
        if (sec < 60) return sec.toFixed(1) + 's';
        const min = Math.floor(sec / 60);
        const remainingSec = sec % 60;
        return min + 'm' + remainingSec.toFixed(0) + 's';
    }

    function showWorkflowConfirm(message, title) {
        return new Promise(function(resolve) {
            document.getElementById('workflowConfirmTitle').textContent = title || 'Confirm';
            document.getElementById('workflowConfirmMessage').textContent = message;

            const modal = new bootstrap.Modal(document.getElementById('workflowConfirmModal'));
            const yesBtn = document.getElementById('workflowConfirmYes');
            const modalEl = document.getElementById('workflowConfirmModal');

            // Clean up old handlers by cloning the button
            const newYesBtn = yesBtn.cloneNode(true);
            yesBtn.parentNode.replaceChild(newYesBtn, yesBtn);

            newYesBtn.onclick = function() {
                modal.hide();
                resolve(true);
            };

            modalEl.addEventListener('hidden.bs.modal', function() {
                resolve(false);
            }, { once: true });

            modal.show();

            // Focus the Yes button when modal is shown
            modalEl.addEventListener('shown.bs.modal', function() {
                newYesBtn.focus();
            }, { once: true });
        });
    }

    function runWorkflow(id, requiresConfirm, confirmMsg, restartServices, wfConfig) {
        // If workflow has inputs, show inputs dialog first
        if (wfConfig && wfConfig.Inputs && wfConfig.Inputs.length > 0) {
            showWorkflowInputs(wfConfig).then(function(inputs) {
                if (inputs === null) return; // User cancelled

                // Now check for confirmation
                if (requiresConfirm) {
                    // Expand confirm message with inputs
                    let msg = confirmMsg || 'Are you sure you want to run this workflow?';
                    msg = expandTemplateWithInputs(msg, inputs);
                    showWorkflowConfirm(msg, 'Run Workflow').then(function(confirmed) {
                        if (confirmed) {
                            executeWorkflow(id, restartServices, inputs);
                        }
                    });
                } else {
                    executeWorkflow(id, restartServices, inputs);
                }
            });
        } else if (requiresConfirm) {
            const msg = confirmMsg || 'Are you sure you want to run this workflow?';
            showWorkflowConfirm(msg, 'Run Workflow').then(function(confirmed) {
                if (confirmed) {
                    executeWorkflow(id, restartServices, null);
                }
            });
        } else {
            executeWorkflow(id, restartServices, null);
        }
    }

    // Simple template expansion for confirm messages
    function expandTemplateWithInputs(template, inputs) {
        if (!template || !inputs) return template;
        // Replace {{ .Inputs.name }} patterns
        return template.replace(/\{\{\s*\.Inputs\.(\w+)\s*\}\}/g, function(match, key) {
            return inputs[key] !== undefined ? inputs[key] : match;
        });
    }

    // Show workflow inputs dialog and return a promise with input values
    function showWorkflowInputs(wfConfig) {
        return new Promise(function(resolve) {
            const form = document.getElementById('workflowInputsForm');
            const titleEl = document.getElementById('workflowInputsTitle');

            // Set title
            titleEl.textContent = wfConfig.Name + ' - Inputs';

            // Clear and build form
            form.innerHTML = '';

            for (const input of wfConfig.Inputs) {
                const div = document.createElement('div');
                div.className = 'mb-3';

                const label = document.createElement('label');
                label.className = 'form-label';
                label.textContent = input.Label || input.Name;
                if (input.Required) {
                    const required = document.createElement('span');
                    required.className = 'text-danger';
                    required.textContent = ' *';
                    label.appendChild(required);
                }
                label.setAttribute('for', 'wf-input-' + input.Name);
                div.appendChild(label);

                if (input.Type === 'select') {
                    const select = document.createElement('select');
                    select.className = 'form-select';
                    select.id = 'wf-input-' + input.Name;
                    select.name = input.Name;
                    if (input.Required) select.required = true;

                    // Add empty option if not required
                    if (!input.Required) {
                        const emptyOpt = document.createElement('option');
                        emptyOpt.value = '';
                        emptyOpt.textContent = '-- Select --';
                        select.appendChild(emptyOpt);
                    }

                    for (const opt of (input.Options || [])) {
                        const option = document.createElement('option');
                        option.value = opt;
                        option.textContent = opt;
                        if (input.Default === opt) option.selected = true;
                        select.appendChild(option);
                    }
                    div.appendChild(select);

                } else if (input.Type === 'checkbox') {
                    const checkDiv = document.createElement('div');
                    checkDiv.className = 'form-check';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'form-check-input';
                    checkbox.id = 'wf-input-' + input.Name;
                    checkbox.name = input.Name;
                    if (input.Default === true) checkbox.checked = true;

                    const checkLabel = document.createElement('label');
                    checkLabel.className = 'form-check-label';
                    checkLabel.setAttribute('for', 'wf-input-' + input.Name);
                    checkLabel.textContent = input.Label || input.Name;

                    checkDiv.appendChild(checkbox);
                    checkDiv.appendChild(checkLabel);

                    // For checkbox, don't add the label above
                    div.innerHTML = '';
                    div.appendChild(checkDiv);

                } else if (input.Type === 'datepicker') {
                    const dateInput = document.createElement('input');
                    dateInput.type = 'date';
                    dateInput.className = 'form-control';
                    dateInput.id = 'wf-input-' + input.Name;
                    dateInput.name = input.Name;
                    if (input.Default) {
                        dateInput.value = input.Default;
                    } else {
                        // Default to today's date
                        dateInput.value = new Date().toISOString().split('T')[0];
                    }
                    if (input.Required) dateInput.required = true;
                    div.appendChild(dateInput);

                } else {
                    // Default to text input
                    const textInput = document.createElement('input');
                    textInput.type = 'text';
                    textInput.className = 'form-control';
                    textInput.id = 'wf-input-' + input.Name;
                    textInput.name = input.Name;
                    if (input.Placeholder) textInput.placeholder = input.Placeholder;
                    if (input.Default) textInput.value = input.Default;
                    if (input.Required) textInput.required = true;
                    div.appendChild(textInput);
                }

                form.appendChild(div);
            }

            const modal = new bootstrap.Modal(document.getElementById('workflowInputsModal'));
            const continueBtn = document.getElementById('workflowInputsContinue');
            const modalEl = document.getElementById('workflowInputsModal');

            // Clone button to remove old listeners
            const newContinueBtn = continueBtn.cloneNode(true);
            continueBtn.parentNode.replaceChild(newContinueBtn, continueBtn);

            newContinueBtn.addEventListener('click', function() {
                // Validate required fields
                if (!form.checkValidity()) {
                    form.reportValidity();
                    return;
                }

                // Collect input values
                const inputs = {};
                for (const input of wfConfig.Inputs) {
                    const el = document.getElementById('wf-input-' + input.Name);
                    if (input.Type === 'checkbox') {
                        inputs[input.Name] = el.checked;
                    } else {
                        inputs[input.Name] = el.value;
                    }
                }

                modal.hide();
                resolve(inputs);
            }, { once: true });

            modalEl.addEventListener('hidden.bs.modal', function() {
                resolve(null); // User cancelled
            }, { once: true });

            modal.show();

            // Focus first input when modal is shown
            modalEl.addEventListener('shown.bs.modal', function() {
                const firstInput = form.querySelector('input, select');
                if (firstInput) firstInput.focus();
            }, { once: true });
        });
    }

    function executeWorkflow(id, restartServices, inputs) {
        const output = document.querySelector('#workflow-output code');
        showWorkflowOutput('Running: ' + id);

        // Close any existing WebSocket connection
        if (currentWorkflowWs) {
            currentWorkflowWs.close();
            currentWorkflowWs = null;
        }

        // If restartServices is enabled, stop watched services first (not databases, etc.)
        if (restartServices) {
            output.textContent = 'Stopping watched services...\n';
            fetch('/api/v1/workflows/_stop_watched/run?worktree=' + encodeURIComponent(currentWorktree), { method: 'POST' })
                .then(r => r.json())
                .then(data => {
                    if (data.error) {
                        output.textContent += 'Error stopping services: ' + data.error.message + '\n';
                    } else {
                        output.textContent += 'Watched services stopped.\n\n';
                    }
                    // Now run the actual workflow
                    runActualWorkflow(id, output, inputs);
                })
                .catch(err => {
                    output.textContent += 'Error stopping services: ' + err + '\n';
                    // Still try to run the workflow
                    runActualWorkflow(id, output, inputs);
                });
        } else {
            output.textContent = 'Starting workflow...\n';
            runActualWorkflow(id, output, inputs);
        }
    }

    let currentWorkflowWs = null; // Track current workflow WebSocket connection

    function runActualWorkflow(id, output, inputs) {
        const fetchOptions = {
            method: 'POST',
            headers: {}
        };

        // If we have inputs, send them as JSON body
        if (inputs && Object.keys(inputs).length > 0) {
            fetchOptions.headers['Content-Type'] = 'application/json';
            fetchOptions.body = JSON.stringify({ inputs: inputs });
        }

        fetch('/api/v1/workflows/' + id + '/run?worktree=' + encodeURIComponent(currentWorktree), fetchOptions)
            .then(r => r.json())
            .then(data => {
                if (data.error) {
                    output.textContent += '\nError: ' + data.error.message;
                    document.getElementById('workflow-title').innerHTML =
                        '<i class="fa-solid fa-bolt"></i> ' + id + ' - ✗ ERROR';
                } else if (data.data) {
                    const status = data.data;
                    // For built-in workflows (synchronous), show result immediately
                    if (status.State !== 'running') {
                        displayWorkflowResult(id, status);
                    } else {
                        // Stream output via WebSocket
                        streamWorkflowOutput(status.ID, id, output);
                    }
                }
            })
            .catch(err => {
                output.textContent += '\nError: ' + err;
            });
    }

    function streamWorkflowOutput(runID, workflowId, output) {
        // Close any existing WebSocket
        if (currentWorkflowWs) {
            currentWorkflowWs.close();
            currentWorkflowWs = null;
        }

        // Build WebSocket URL
        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = protocol + '//' + window.location.host + '/api/v1/workflows/' + encodeURIComponent(runID) + '/stream';

        output.innerHTML = 'Running...<br><br>';
        let outputLines = [];

        // Store initial state so navigating away and back shows output
        const worktreeForOutput = currentWorktree;
        workflowOutputs[worktreeForOutput] = {
            title: workflowId + ' - Running...',
            html: 'Running...<br><br>'
        };

        const ws = new WebSocket(wsUrl);
        currentWorkflowWs = ws;

        ws.onopen = () => {
            // Connection established
        };

        ws.onmessage = (event) => {
            try {
                const msg = JSON.parse(event.data);

                if (msg.type === 'output') {
                    // Append new line of output
                    const escapedLine = (msg.line || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
                    outputLines.push(escapedLine);
                    const currentHtml = 'Running...<br><br>' + outputLines.join('');
                    output.innerHTML = currentHtml;

                    // Store output so navigating away and back shows progress
                    workflowOutputs[worktreeForOutput] = {
                        title: workflowId + ' - Running...',
                        html: currentHtml
                    };

                    // Auto-scroll output
                    const wrapper = document.getElementById('workflow-output');
                    wrapper.scrollTop = wrapper.scrollHeight;

                } else if (msg.type === 'done') {
                    // Workflow completed
                    currentWorkflowWs = null;
                    ws.close();
                    if (msg.status) {
                        displayWorkflowResult(workflowId, msg.status);
                    }

                } else if (msg.type === 'error') {
                    output.textContent += '\nError: ' + msg.error;
                    currentWorkflowWs = null;
                }
            } catch (e) {
                console.error('Failed to parse workflow message:', e);
            }
        };

        ws.onerror = (err) => {
            console.error('Workflow WebSocket error:', err);
            output.textContent += '\nWebSocket error';
            currentWorkflowWs = null;
        };

        ws.onclose = () => {
            currentWorkflowWs = null;
        };
    }

    function displayWorkflowResult(workflowId, status) {
        const output = document.querySelector('#workflow-output code');
        const result = status.Success ? '✓ SUCCESS' : '✗ FAILED';
        const duration = formatDuration(status.Duration);
        const title = workflowId + ' - ' + result;

        // Use server-formatted HTML output if available, otherwise fall back to plain text
        const header = result + ' (took ' + duration + ')<br><br>';
        let outputHtml;
        if (status.OutputHTML) {
            outputHtml = header + status.OutputHTML;
        } else {
            // Fallback: escape and convert newlines
            let text = (status.Output || status.Error || '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br>');
            outputHtml = header + text;
        }

        output.innerHTML = outputHtml;

        document.getElementById('workflow-title').innerHTML =
            '<i class="fa-solid fa-bolt"></i> ' + title;

        // Store workflow output for this worktree
        workflowOutputs[currentWorktree] = {
            title: title,
            html: outputHtml
        };

        // Auto-scroll to end
        const wrapper = document.getElementById('workflow-output');
        wrapper.scrollTop = wrapper.scrollHeight;
    }

    function openFileAtLine(fileOrPath, line, col) {
        const session = getCurrentSession();

        // Handle both formats:
        // openFileAtLine('file:line:col') - single string from Go errors
        // openFileAtLine('file', line, col) - separate arguments from qtc errors
        let file = fileOrPath;
        let lineNum = line;
        let colNum = col;

        if (line === undefined) {
            // Parse file:line:col format
            const parts = fileOrPath.split(':');
            if (parts.length >= 2) {
                file = parts[0];
                lineNum = parseInt(parts[1], 10) || 1;
                colNum = parseInt(parts[2], 10) || 1;
            }
        }

        // Function to call API to open file at line
        const callOpenFile = () => {
            fetch('/api/v1/vscode/open?session=' + encodeURIComponent(session) +
                '&file=' + encodeURIComponent(file) +
                '&line=' + (lineNum || 1) + '&col=' + (colNum || 1), { method: 'POST' })
                .then(r => r.json())
                .catch(err => console.error('Error opening file:', err));
        };

        // Show the embedded editor
        showCode();

        // If code-server is ready, call immediately; otherwise queue the callback
        if (codeServerReady) {
            callOpenFile();
        } else {
            pendingCodeServerCallbacks.push(callOpenFile);
        }
    }

    // Service log functions
    function showService(serviceName) {
        // Save to navigation history (use URL)
        if (currentTerminalKey && currentTerminalKey !== '#' + serviceName) {
            pushToScreenHistory(window.location.pathname);
        }

        // Hide current terminal container
        if (currentTerminalKey && terminals[currentTerminalKey]) {
            terminals[currentTerminalKey].container.style.display = 'none';
        }

        // Close log viewer websocket if active
        closeLogViewerWs();

        // Hide other views, show service view
        document.getElementById('terminal-wrapper').style.display = 'none';
        document.getElementById('code-wrapper').style.display = 'none';
        if (document.getElementById('workflow-wrapper')) {
            document.getElementById('workflow-wrapper').style.display = 'none';
        }
        if (document.getElementById('logviewer-wrapper')) {
            document.getElementById('logviewer-wrapper').style.display = 'none';
        }
        document.getElementById('service-wrapper').style.display = 'flex';

        // Hide workflow selector (not applicable for service logs)
        const workflowSelect = document.getElementById('workflowSelect');
        if (workflowSelect) {
            workflowSelect.style.display = 'none';
        }
        const showCodeBtn = document.getElementById('showCodeBtn');
        if (showCodeBtn) {
            showCodeBtn.style.display = 'none';
        }

        if (document.getElementById('showTerminalBtn')) {
            document.getElementById('showTerminalBtn').classList.remove('active');
            document.getElementById('showCodeBtn').classList.remove('active');
        }

        currentServiceName = serviceName;
        currentTerminalKey = '#' + serviceName;

        document.getElementById('service-name').textContent = serviceName;
        document.title = 'Service: ' + serviceName;

        // Look up service config for structured logging
        serviceLogConfig = initialServices.find(s => s.name === serviceName);
        const isStructured = serviceLogConfig && serviceLogConfig.parser_type;

        if (isStructured) {
            // Set up structured log display
            document.getElementById('service-log').style.display = 'none';
            document.getElementById('service-log-table').style.display = 'block';
            document.getElementById('service-filter-container').style.display = 'flex';
            document.getElementById('service-mode-btn').style.display = 'flex';

            // Set up layout configuration
            if (serviceLogConfig.layout && serviceLogConfig.layout.length > 0) {
                serviceLogLayout = serviceLogConfig.layout;
            } else if (serviceLogConfig.columns && serviceLogConfig.columns.length > 0) {
                // Legacy: convert columns to layout format
                serviceLogLayout = serviceLogConfig.columns.map(col => ({
                    field: col,
                    max_width: (serviceLogConfig.column_widths || {})[col] || 0,
                    timestamp: col === 'timestamp' || col === serviceLogConfig.timestamp_field
                }));
            } else {
                // Default layout
                serviceLogLayout = [
                    { field: 'timestamp', max_width: 12, timestamp: true },
                    { field: 'level', max_width: 6 },
                    { field: 'message', max_width: 0 }
                ];
            }

            // Set up field maps (for mapping parsed fields to core fields)
            serviceLogFieldMap = {};
            serviceLogFieldNames = {};
            if (serviceLogConfig.timestamp_field) {
                serviceLogFieldMap[serviceLogConfig.timestamp_field] = 'timestamp';
                serviceLogFieldNames['timestamp'] = serviceLogConfig.timestamp_field;
            }
            if (serviceLogConfig.level_field) {
                serviceLogFieldMap[serviceLogConfig.level_field] = 'level';
                serviceLogFieldNames['level'] = serviceLogConfig.level_field;
            }
            if (serviceLogConfig.message_field) {
                serviceLogFieldMap[serviceLogConfig.message_field] = 'message';
                serviceLogFieldNames['message'] = serviceLogConfig.message_field;
            }

            // Reset state
            serviceLogEntries = [];
            serviceLogFilteredEntries = [];
            serviceLogFilter = '';
            serviceLogFollowing = true;
            serviceLogNewLinesCount = 0;
            serviceLogSelectedEntry = null;
            document.getElementById('service-log-table').innerHTML = '';
            document.getElementById('service-filter').value = '';
            document.getElementById('service-expanded').style.display = 'none';
            updateServiceLogModeUI();

            // Set up scroll listener
            const logEl = document.getElementById('service-log-table');
            logEl.onscroll = handleServiceLogScroll;
        } else {
            // Use raw log display
            document.getElementById('service-log').style.display = 'block';
            document.getElementById('service-log-table').style.display = 'none';
            document.getElementById('service-filter-container').style.display = 'none';
            document.getElementById('service-mode-btn').style.display = 'none';
            document.getElementById('service-newlines-btn').style.display = 'none';
            document.getElementById('service-log').textContent = 'Loading logs...';
            serviceLogConfig = null;
        }

        lastLogLength = 0; // Reset so fetchServiceLogs always updates display

        // Fetch initial logs and status
        updateServiceStatus();
        fetchServiceLogs();

        // Start polling for updates
        if (serviceLogPollTimer) {
            clearInterval(serviceLogPollTimer);
        }
        serviceLogPollTimer = setInterval(() => {
            updateServiceStatus();
            fetchServiceLogs();
        }, 1000);

        // Update URL without navigating (for bookmarking/refresh)
        const serviceUrl = '/terminal/service/' + encodeURIComponent(serviceName);
        history.pushState({ type: 'service', service: serviceName }, '', serviceUrl);

        // Update picker to match (use URL)
        $('#navSelect').val(serviceUrl).trigger('change.select2');
    }

    function updateServiceStatus() {
        if (!currentServiceName) return;

        fetch('/api/v1/services/' + encodeURIComponent(currentServiceName))
            .then(r => r.json())
            .then(data => {
                if (data.data) {
                    // API returns { data: { Status: { State: "running" } } }
                    const status = (data.data.Status && data.data.Status.State) || 'unknown';
                    const statusEl = document.getElementById('service-status');
                    statusEl.textContent = status;
                    statusEl.className = 'service-status ' + status.toLowerCase();

                    // Update button states
                    const stopBtn = document.getElementById('service-stop-btn');
                    const restartBtn = document.getElementById('service-restart-btn');
                    if (status === 'running') {
                        stopBtn.disabled = false;
                        restartBtn.disabled = false;
                    } else if (status === 'stopped') {
                        stopBtn.disabled = true;
                        restartBtn.disabled = false;
                    } else {
                        stopBtn.disabled = false;
                        restartBtn.disabled = false;
                    }
                }
            })
            .catch(err => console.error('Error fetching service status:', err));
    }

    function fetchServiceLogs() {
        if (!currentServiceName) return;

        fetch('/api/v1/services/' + encodeURIComponent(currentServiceName) + '/logs?lines=1000')
            .then(r => r.json())
            .then(data => {
                // API returns either:
                // { data: { service: "name", entries: [...] } } - server-parsed entries
                // { data: { service: "name", lines: [...] } } - raw lines
                const entries = data.data && data.data.entries;
                const lines = data.data && data.data.lines;

                // Check if using structured log display
                const isStructured = serviceLogConfig && serviceLogConfig.parser_type;

                if (isStructured) {
                    // Structured log display
                    if (entries && entries.length > 0) {
                        // Server-parsed entries - use directly
                        const newLineCount = entries.length;

                        if (newLineCount !== lastLogLength) {
                            // Convert server entries to frontend format
                            serviceLogEntries = entries.map(e => ({
                                timestamp: e.timestamp,
                                level: e.level,
                                message: e.message,
                                fields: e.fields || {},
                                _raw: e.raw
                            }));

                            // Apply filter
                            if (serviceLogFilter) {
                                serviceLogFilteredEntries = serviceLogEntries.filter(e =>
                                    matchesServiceLogFilter(e, serviceLogFilter));
                            } else {
                                serviceLogFilteredEntries = [...serviceLogEntries];
                            }

                            // Count new entries
                            const addedCount = newLineCount - lastLogLength;
                            if (addedCount > 0 && !serviceLogFollowing) {
                                serviceLogNewLinesCount += addedCount;
                                updateServiceLogModeUI();
                            }

                            lastLogLength = newLineCount;
                            rerenderServiceLog();
                        }
                    } else if (lines && lines.length > 0) {
                        // Fallback: parse raw lines client-side
                        const newLineCount = lines.length;

                        if (newLineCount !== lastLogLength) {
                            serviceLogEntries = [];
                            for (const line of lines) {
                                const entry = parseServiceLogLine(line);
                                if (entry) {
                                    serviceLogEntries.push(entry);
                                }
                            }

                            if (serviceLogFilter) {
                                serviceLogFilteredEntries = serviceLogEntries.filter(e =>
                                    matchesServiceLogFilter(e, serviceLogFilter));
                            } else {
                                serviceLogFilteredEntries = [...serviceLogEntries];
                            }

                            const addedCount = newLineCount - lastLogLength;
                            if (addedCount > 0 && !serviceLogFollowing) {
                                serviceLogNewLinesCount += addedCount;
                                updateServiceLogModeUI();
                            }

                            lastLogLength = newLineCount;
                            rerenderServiceLog();
                        }
                    } else {
                        serviceLogEntries = [];
                        serviceLogFilteredEntries = [];
                        document.getElementById('service-log-table').innerHTML = '';
                        lastLogLength = 0;
                    }
                } else {
                    // Raw log display
                    const logEl = document.getElementById('service-log');
                    if (lines) {
                        const logs = lines.join('\n');

                        // Only update and scroll if content changed
                        if (logs.length !== lastLogLength) {
                            const wasAtBottom = logEl.scrollHeight - logEl.scrollTop <= logEl.clientHeight + 50;
                            logEl.textContent = logs || '(no logs)';
                            lastLogLength = logs.length;

                            // Auto-scroll if we were at the bottom
                            if (wasAtBottom) {
                                logEl.scrollTop = logEl.scrollHeight;
                            }
                        }
                    } else {
                        logEl.textContent = '(no logs)';
                        lastLogLength = 0;
                    }
                }
            })
            .catch(err => {
                console.error('Error fetching service logs:', err);
                if (serviceLogConfig && serviceLogConfig.parser_type) {
                    document.getElementById('service-log-table').innerHTML =
                        '<tr><td colspan="10">Error loading logs: ' + escapeHtml(err.toString()) + '</td></tr>';
                } else {
                    document.getElementById('service-log').textContent = 'Error loading logs: ' + err;
                }
            });
    }

    function parseServiceLogLine(line) {
        if (!line || !line.trim()) return null;

        const parserType = serviceLogConfig ? serviceLogConfig.parser_type : 'none';

        if (parserType === 'json') {
            try {
                const parsed = JSON.parse(line);
                // Create entry with fields structure matching log viewer
                const entry = { _raw: line, fields: {} };

                // Extract timestamp field
                const tsField = serviceLogConfig.timestamp_field;
                if (tsField && parsed[tsField] !== undefined) {
                    entry.timestamp = parsed[tsField];
                }

                // Extract level field
                const levelField = serviceLogConfig.level_field;
                if (levelField && parsed[levelField] !== undefined) {
                    entry.level = String(parsed[levelField]).toUpperCase();
                }

                // Extract message field (if configured)
                const msgField = serviceLogConfig.message_field;
                if (msgField && parsed[msgField] !== undefined) {
                    entry.message = parsed[msgField];
                }

                // Put remaining fields in entry.fields (matching log viewer structure)
                for (const [key, value] of Object.entries(parsed)) {
                    // Skip fields that were extracted to top-level
                    if (key === tsField || key === levelField || key === msgField) {
                        continue;
                    }
                    entry.fields[key] = value;
                }

                return entry;
            } catch (e) {
                // Not valid JSON, return as raw message
                return { _raw: line, message: line, fields: {} };
            }
        } else if (parserType === 'logfmt') {
            // Parse logfmt: key=value key2="quoted value"
            // Key pattern allows dots and dashes (common in logfmt, e.g., http.method, response-time)
            const entry = { _raw: line, fields: {} };
            const regex = /([\w.-]+)=(?:"([^"]*)"|(\S+))/g;
            let match;

            const tsField = serviceLogConfig.timestamp_field;
            const levelField = serviceLogConfig.level_field;
            const msgField = serviceLogConfig.message_field;

            while ((match = regex.exec(line)) !== null) {
                const key = match[1];
                const value = match[2] !== undefined ? match[2] : match[3];

                // Map to top-level fields or put in fields object
                if (key === tsField) {
                    entry.timestamp = value;
                } else if (key === levelField) {
                    entry.level = String(value).toUpperCase();
                } else if (key === msgField) {
                    entry.message = value;
                } else {
                    entry.fields[key] = value;
                }
            }
            // If no fields parsed, use whole line as message
            if (!entry.timestamp && !entry.level && !entry.message && Object.keys(entry.fields).length === 0) {
                entry.message = line;
            }
            return entry;
        } else {
            // No parsing, just raw message
            return { _raw: line, message: line, fields: {} };
        }
    }

    function matchesServiceLogFilter(entry, filter) {
        if (!filter) return true;

        // Parse filter: field:value or field:~regex or just text
        const parts = filter.split(/\s+/);
        for (const part of parts) {
            if (!part) continue;

            const colonIdx = part.indexOf(':');
            if (colonIdx > 0) {
                const field = part.substring(0, colonIdx);
                let value = part.substring(colonIdx + 1);

                // Get entry value for field (check top-level and entry.fields)
                let fieldValue = entry[field];
                if (fieldValue === undefined && entry.fields) {
                    fieldValue = entry.fields[field];
                }
                const entryValue = String(fieldValue || '').toLowerCase();

                if (value.startsWith('~')) {
                    // Regex match
                    try {
                        const regex = new RegExp(value.substring(1), 'i');
                        if (!regex.test(entryValue)) return false;
                    } catch (e) {
                        // Invalid regex, treat as literal
                        if (!entryValue.includes(value.substring(1).toLowerCase())) return false;
                    }
                } else {
                    // Exact match (case insensitive)
                    value = value.toLowerCase().replace(/^"|"$/g, '');
                    if (!entryValue.includes(value)) return false;
                }
            } else {
                // Full text search
                const searchText = part.toLowerCase();
                const rawText = (entry._raw || '').toLowerCase();
                if (!rawText.includes(searchText)) return false;
            }
        }
        return true;
    }

    function rerenderServiceLog() {
        const tbody = document.getElementById('service-log-table');
        tbody.innerHTML = '';

        for (let i = 0; i < serviceLogFilteredEntries.length; i++) {
            const entry = serviceLogFilteredEntries[i];
            renderServiceLogEntry(entry, i);
        }

        // Auto-scroll if following
        if (serviceLogFollowing) {
            const logEl = document.getElementById('service-log-table');
            logEl.scrollTop = logEl.scrollHeight;
        }
    }

    function renderServiceLogEntry(entry, index) {
        renderLogEntry(entry, {
            container: document.getElementById('service-log-table'),
            layout: serviceLogLayout,
            fieldMap: serviceLogFieldMap,
            formatTs: (ts) => formatTimestamp(ts, serviceLogTimestampAbsolute),
            onExpand: expandServiceEntry,
            entryIndex: index
        });
    }

    function formatServiceLogTimestamp(timestamp) {
        return formatTimestamp(timestamp, serviceLogTimestampAbsolute);
    }

    function handleServiceLogScroll() {
        const logEl = document.getElementById('service-log-table');
        const isAtBottom = logEl.scrollHeight - logEl.scrollTop <= logEl.clientHeight + 50;

        if (isAtBottom && !serviceLogFollowing) {
            // User scrolled to bottom, resume following
            serviceLogFollowing = true;
            serviceLogNewLinesCount = 0;
            updateServiceLogModeUI();
        } else if (!isAtBottom && serviceLogFollowing) {
            // User scrolled up, pause following
            serviceLogFollowing = false;
            updateServiceLogModeUI();
        }
    }

    function updateServiceLogModeUI() {
        const modeBtn = document.getElementById('service-mode-btn');
        const modeDot = document.getElementById('service-mode-dot');
        const modeIndicator = document.getElementById('service-mode-indicator');
        const newLinesBtn = document.getElementById('service-newlines-btn');
        const newLinesCount = document.getElementById('service-newlines-count');

        if (serviceLogFollowing) {
            modeIndicator.textContent = 'Following';
            modeDot.style.background = '#56ab2f';
            newLinesBtn.style.display = 'none';
        } else {
            modeIndicator.textContent = 'Paused';
            modeDot.style.background = '#f59e0b';
            if (serviceLogNewLinesCount > 0) {
                newLinesBtn.style.display = 'flex';
                newLinesCount.textContent = '+' + serviceLogNewLinesCount + ' new lines';
            } else {
                newLinesBtn.style.display = 'none';
            }
        }
    }

    function toggleServiceLogFollowing() {
        serviceLogFollowing = !serviceLogFollowing;
        if (serviceLogFollowing) {
            serviceLogNewLinesCount = 0;
            const logEl = document.getElementById('service-log-table');
            logEl.scrollTop = logEl.scrollHeight;
        }
        updateServiceLogModeUI();
    }

    function jumpToLatestServiceLogs() {
        serviceLogFollowing = true;
        serviceLogNewLinesCount = 0;
        const logEl = document.getElementById('service-log-table');
        logEl.scrollTop = logEl.scrollHeight;
        updateServiceLogModeUI();
    }

    function applyServiceLogFilter(event) {
        if (event && event.key !== 'Enter') return;

        const filterInput = document.getElementById('service-filter');
        serviceLogFilter = filterInput.value.trim();

        // Refilter entries
        if (serviceLogFilter) {
            serviceLogFilteredEntries = serviceLogEntries.filter(e =>
                matchesServiceLogFilter(e, serviceLogFilter));
        } else {
            serviceLogFilteredEntries = [...serviceLogEntries];
        }
        rerenderServiceLog();
    }

    function clearServiceLogFilter() {
        document.getElementById('service-filter').value = '';
        serviceLogFilter = '';
        serviceLogFilteredEntries = [...serviceLogEntries];
        rerenderServiceLog();
    }

    function expandServiceEntry(entry) {
        expandEntry(entry, {
            expandedEl: document.getElementById('service-expanded'),
            contentEl: document.getElementById('service-expanded-content'),
            fieldNames: serviceLogFieldNames,
            tbodySelector: '#service-log-table',
            filteredEntries: serviceLogFilteredEntries,
            onSelect: (e) => { serviceLogSelectedEntry = e; }
        });
    }

    function closeServiceExpanded() {
        document.getElementById('service-expanded').style.display = 'none';
        document.querySelectorAll('#service-log-table .logviewer-entry.selected').forEach(el =>
            el.classList.remove('selected'));
        serviceLogSelectedEntry = null;
    }

    function stopService() {
        if (!currentServiceName) return;

        fetch('/api/v1/services/' + encodeURIComponent(currentServiceName) + '/stop', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.error) {
                    alert('Failed to stop service: ' + data.error.message);
                }
                updateServiceStatus();
            })
            .catch(err => alert('Error stopping service: ' + err));
    }

    function restartService() {
        if (!currentServiceName) return;

        fetch('/api/v1/services/' + encodeURIComponent(currentServiceName) + '/restart', { method: 'POST' })
            .then(r => r.json())
            .then(data => {
                if (data.error) {
                    alert('Failed to restart service: ' + data.error.message);
                }
                updateServiceStatus();
            })
            .catch(err => alert('Error restarting service: ' + err));
    }

    function clearServiceLog() {
        if (!currentServiceName) return;

        fetch('/api/v1/services/' + encodeURIComponent(currentServiceName) + '/logs', { method: 'DELETE' })
            .then(r => r.json())
            .then(data => {
                if (data.error) {
                    alert('Failed to clear logs: ' + data.error.message);
                } else {
                    // Clear both raw and structured displays
                    document.getElementById('service-log').textContent = '';
                    document.getElementById('service-log-table').innerHTML = '';
                    serviceLogEntries = [];
                    serviceLogFilteredEntries = [];
                    serviceLogNewLinesCount = 0;
                    lastLogLength = 0;
                    updateServiceLogModeUI();
                }
            })
            .catch(err => alert('Error clearing logs: ' + err));
    }

    // Log viewer functions
    function showLogViewer(logViewerName) {
        // Skip if already showing this log viewer (prevents duplicate calls)
        if (currentTerminalKey === '~' + logViewerName &&
            document.getElementById('logviewer-wrapper').style.display !== 'none') {
            return;
        }

        // Save to navigation history (use URL)
        if (currentTerminalKey && currentTerminalKey !== '~' + logViewerName) {
            pushToScreenHistory(window.location.pathname);
        }

        // Hide current terminal container
        if (currentTerminalKey && terminals[currentTerminalKey]) {
            terminals[currentTerminalKey].container.style.display = 'none';
        }

        // Stop service log polling if active
        if (serviceLogPollTimer) {
            clearInterval(serviceLogPollTimer);
            serviceLogPollTimer = null;
        }
        currentServiceName = null;

        // Close existing log viewer websocket if different log viewer
        if (logViewerWs && currentLogViewerName !== logViewerName) {
            logViewerWs.onclose = null;  // Prevent reconnect on intentional close
            logViewerWs.onerror = null;  // Prevent error logging on intentional close
            logViewerWs.close();
            logViewerWs = null;
        }

        // Hide other views, show log viewer view
        document.getElementById('terminal-wrapper').style.display = 'none';
        document.getElementById('code-wrapper').style.display = 'none';
        if (document.getElementById('workflow-wrapper')) {
            document.getElementById('workflow-wrapper').style.display = 'none';
        }
        document.getElementById('service-wrapper').style.display = 'none';
        document.getElementById('logviewer-wrapper').style.display = 'flex';

        // Hide workflow selector (not applicable for log viewers)
        const workflowSelect = document.getElementById('workflowSelect');
        if (workflowSelect) {
            workflowSelect.style.display = 'none';
        }
        const showCodeBtn = document.getElementById('showCodeBtn');
        if (showCodeBtn) {
            showCodeBtn.style.display = 'none';
        }

        if (document.getElementById('showTerminalBtn')) {
            document.getElementById('showTerminalBtn').classList.remove('active');
            document.getElementById('showCodeBtn').classList.remove('active');
        }

        currentLogViewerName = logViewerName;
        currentTerminalKey = '~' + logViewerName;
        document.title = 'Log Viewer: ' + logViewerName;

        // Look up display config for this log viewer
        const viewerConfig = initialLogViewers.find(lv => lv.name === logViewerName);
        if (viewerConfig && viewerConfig.layout && viewerConfig.layout.length > 0) {
            // Use new layout format
            logViewerLayout = viewerConfig.layout;
            logViewerColumns = viewerConfig.layout.map(col => col.field || col.type || 'unknown');
            logViewerColumnWidths = {};
            for (const col of viewerConfig.layout) {
                if (col.field && col.max_width) {
                    logViewerColumnWidths[col.field] = col.max_width;
                }
            }
        } else if (viewerConfig && viewerConfig.columns && viewerConfig.columns.length > 0) {
            // Fall back to legacy columns format
            logViewerLayout = viewerConfig.columns.map(field => ({ field }));
            logViewerColumns = viewerConfig.columns;
            logViewerColumnWidths = viewerConfig.column_widths || {};
        } else {
            // Default columns if not configured
            logViewerLayout = [{ field: 'timestamp' }, { field: 'level' }, { field: 'message' }];
            logViewerColumns = ['timestamp', 'level', 'message'];
            logViewerColumnWidths = {};
        }

        // Build field map from parser config (maps column names to entry properties)
        logViewerFieldMap = {};
        logViewerFieldNames = { timestamp: 'timestamp', level: null, message: null };
        if (viewerConfig) {
            // Map the parser's field names to entry properties
            if (viewerConfig.timestamp_field) {
                logViewerFieldMap[viewerConfig.timestamp_field] = 'timestamp';
                logViewerFieldNames.timestamp = viewerConfig.timestamp_field;
            }
            if (viewerConfig.level_field) {
                logViewerFieldMap[viewerConfig.level_field] = 'level';
                logViewerFieldNames.level = viewerConfig.level_field;
            }
            if (viewerConfig.message_field) {
                logViewerFieldMap[viewerConfig.message_field] = 'message';
                logViewerFieldNames.message = viewerConfig.message_field;
            }
        }

        // Reset log viewer state
        logViewerEntries = [];
        logViewerFilteredEntries = [];
        logViewerFollowing = true;
        logViewerNewLinesCount = 0;
        logViewerFilter = '';
        logViewerSelectedEntry = null;
        logViewerOldestSeq = null;
        logViewerLoadingMore = false;
        logViewerNoMoreEntries = false;

        // Restore timestamp format preference from localStorage
        const savedTimestampPref = localStorage.getItem('trellis-logviewer-timestamp-absolute');
        if (savedTimestampPref !== null) {
            logViewerTimestampAbsolute = savedTimestampPref === '1';
        }

        // Stop any existing interval
        if (logViewerRelativeTimeInterval) {
            clearInterval(logViewerRelativeTimeInterval);
            logViewerRelativeTimeInterval = null;
        }

        // Start interval if using relative timestamps
        if (!logViewerTimestampAbsolute) {
            logViewerRelativeTimeInterval = setInterval(updateLogViewerTimestamps, 1000);
        }

        document.getElementById('logviewer-name').textContent = logViewerName;
        document.getElementById('logviewer-status').textContent = 'connecting...';
        document.getElementById('logviewer-status').className = 'logviewer-connection-status';
        document.getElementById('logviewer-log').innerHTML = '';
        document.getElementById('logviewer-filter').value = '';
        document.getElementById('logviewer-expanded').style.display = 'none';
        updateLogViewerModeUI();

        // Set up scroll listener for pause detection
        const logEl = document.getElementById('logviewer-log');
        logEl.onscroll = handleLogViewerScroll;

        // Connect to log viewer websocket stream
        connectLogViewerWs(logViewerName);

        // Update URL without navigating (for bookmarking/refresh)
        const logViewerUrl = '/terminal/logviewer/' + encodeURIComponent(logViewerName);
        history.pushState({ type: 'logviewer', name: logViewerName }, '', logViewerUrl);

        // Update picker to match (use URL)
        $('#navSelect').val(logViewerUrl).trigger('change.select2');
    }

    function connectLogViewerWs(logViewerName) {
        // Cancel any pending reconnect timer
        if (logViewerReconnectTimer) {
            clearTimeout(logViewerReconnectTimer);
            logViewerReconnectTimer = null;
        }

        // If already connected or connecting to the same log viewer, skip
        if (logViewerWs && currentLogViewerName === logViewerName &&
            (logViewerWs.readyState === WebSocket.CONNECTING || logViewerWs.readyState === WebSocket.OPEN)) {
            return;
        }

        if (logViewerWs) {
            logViewerWs.onclose = null;  // Prevent reconnect on intentional close
            logViewerWs.onerror = null;  // Prevent error logging on intentional close
            logViewerWs.close();
            logViewerWs = null;
        }

        const wsProto = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        let wsUrl = wsProto + '//' + window.location.host + '/api/v1/logs/' + encodeURIComponent(logViewerName) + '/stream';
        if (logViewerFilter) {
            wsUrl += '?filter=' + encodeURIComponent(logViewerFilter);
        }

        logViewerWs = new WebSocket(wsUrl);

        logViewerWs.onopen = function() {
            document.getElementById('logviewer-status').textContent = 'connected';
            document.getElementById('logviewer-status').className = 'logviewer-connection-status connected';
        };

        logViewerWs.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);

                // Handle different message types
                if (data.type === 'status') {
                    // Connection status message
                    return;
                }

                if (data.type === 'older_entries') {
                    // Older entries loaded via scroll-to-top
                    logViewerLoadingMore = false;
                    if (data.no_more || !data.entries || data.entries.length === 0) {
                        logViewerNoMoreEntries = true;
                        return;
                    }
                    prependLogViewerEntries(data.entries);
                    return;
                }

                // Entry or entries message
                const entries = data.type === 'entries' ? data.entries :
                               data.type === 'entry' ? [data.entry] :
                               [data]; // Fallback for direct entry

                for (const entry of entries) {
                    addLogViewerEntry(entry);
                }
            } catch (e) {
                // If not JSON, create a raw entry
                addLogViewerEntry({
                    timestamp: new Date().toISOString(),
                    message: event.data,
                    raw: event.data
                });
            }
        };

        logViewerWs.onclose = function() {
            document.getElementById('logviewer-status').textContent = 'disconnected';
            document.getElementById('logviewer-status').className = 'logviewer-connection-status disconnected';

            // Attempt to reconnect after a delay if still viewing this log
            if (currentLogViewerName === logViewerName) {
                logViewerReconnectTimer = setTimeout(() => {
                    logViewerReconnectTimer = null;
                    if (currentLogViewerName === logViewerName) {
                        document.getElementById('logviewer-status').textContent = 'reconnecting...';
                        document.getElementById('logviewer-status').className = 'logviewer-connection-status';
                        connectLogViewerWs(logViewerName);
                    }
                }, 3000);
            }
        };

        logViewerWs.onerror = function(err) {
            console.error('Log viewer WebSocket error:', err);
            document.getElementById('logviewer-status').textContent = 'error';
            document.getElementById('logviewer-status').className = 'logviewer-connection-status disconnected';
        };
    }

    function addLogViewerEntry(entry) {
        // Add to entries array
        logViewerEntries.push(entry);

        // Track oldest sequence for load-more functionality
        if (entry.sequence !== undefined) {
            if (logViewerOldestSeq === null || entry.sequence < logViewerOldestSeq) {
                logViewerOldestSeq = entry.sequence;
            }
        }

        // Limit entries to prevent memory issues
        const maxEntries = 10000;
        if (logViewerEntries.length > maxEntries) {
            logViewerEntries = logViewerEntries.slice(-maxEntries);
            // Update oldest sequence after trimming
            if (logViewerEntries.length > 0 && logViewerEntries[0].sequence !== undefined) {
                logViewerOldestSeq = logViewerEntries[0].sequence;
            }
        }

        // Check if entry matches current filter
        if (!logViewerFilter || matchesLogViewerFilter(entry, logViewerFilter)) {
            logViewerFilteredEntries.push(entry);

            if (logViewerFollowing) {
                renderLogViewerEntry(entry);
                scrollLogViewerToBottom();
            } else {
                logViewerNewLinesCount++;
                updateNewLinesButton();
            }
        }
    }

    function prependLogViewerEntries(entries) {
        if (!entries || entries.length === 0) return;

        const logEl = document.getElementById('logviewer-log');
        const tbody = document.getElementById('logviewer-log');

        // Save current scroll position and height
        const scrollHeightBefore = logEl.scrollHeight;
        const scrollTopBefore = logEl.scrollTop;

        // Prepend to entries array
        logViewerEntries = entries.concat(logViewerEntries);

        // Update oldest sequence
        for (const entry of entries) {
            if (entry.sequence !== undefined) {
                if (logViewerOldestSeq === null || entry.sequence < logViewerOldestSeq) {
                    logViewerOldestSeq = entry.sequence;
                }
            }
        }

        // Prepend to filtered entries if they match filter
        const matchingEntries = entries.filter(e => !logViewerFilter || matchesLogViewerFilter(e, logViewerFilter));
        if (matchingEntries.length > 0) {
            logViewerFilteredEntries = matchingEntries.concat(logViewerFilteredEntries);

            // Create document fragment for efficient DOM manipulation
            const fragment = document.createDocumentFragment();
            for (const entry of matchingEntries) {
                const row = createLogViewerRow(entry);
                fragment.appendChild(row);
            }

            // Insert at beginning of tbody
            if (tbody.firstChild) {
                tbody.insertBefore(fragment, tbody.firstChild);
            } else {
                tbody.appendChild(fragment);
            }

            // Restore scroll position (adjust for new content height)
            const scrollHeightAfter = logEl.scrollHeight;
            const heightDiff = scrollHeightAfter - scrollHeightBefore;
            logEl.scrollTop = scrollTopBefore + heightDiff;
        }
    }

    function createLogViewerRow(entry) {
        const row = document.createElement('tr');
        row.className = 'log-entry';
        if (entry.level) {
            row.classList.add('level-' + entry.level.toLowerCase());
        }

        // Use layout if available
        const layout = (logViewerLayout && logViewerLayout.length > 0)
            ? logViewerLayout
            : [{field: 'timestamp', timestamp: true}, {field: 'level'}, {field: 'message'}];

        for (const col of layout) {
            const td = document.createElement('td');
            if (col.width) td.style.width = col.width;

            if (col.kvpairs) {
                // Render key-value pairs
                td.innerHTML = renderKvPairs(entry, logViewerFieldMap);
            } else if (col.timestamp) {
                const ts = entry.timestamp || entry[logViewerFieldNames.timestamp];
                td.className = 'log-timestamp';
                td.setAttribute('data-timestamp', ts || '');
                td.textContent = formatTimestamp(ts, logViewerTimestampAbsolute);
            } else {
                const fieldName = col.field;
                const mappedField = logViewerFieldMap[fieldName] || fieldName;
                let value = entry[mappedField] !== undefined ? entry[mappedField] : entry[fieldName];
                if (value === undefined) value = '';
                td.textContent = String(value);
                if (mappedField === 'level' || fieldName === 'level') {
                    td.className = 'log-level';
                }
            }
            row.appendChild(td);
        }

        // Click handler for expansion
        row.onclick = function() { expandLogViewerEntry(entry, row); };

        return row;
    }

    function matchesLogViewerFilter(entry, filter) {
        if (!filter) return true;

        // Simple filter matching
        const parts = filter.toLowerCase().split(/\s+/);
        for (const part of parts) {
            if (part.startsWith('level:')) {
                const level = part.substring(6);
                if (entry.level && !entry.level.toLowerCase().includes(level)) {
                    return false;
                }
            } else if (part.startsWith('msg:~')) {
                const text = part.substring(5).replace(/"/g, '');
                if (!entry.message || !entry.message.toLowerCase().includes(text)) {
                    return false;
                }
            } else if (part.startsWith('-level:')) {
                const level = part.substring(7);
                if (entry.level && entry.level.toLowerCase() === level) {
                    return false;
                }
            } else if (part.startsWith('"') && part.endsWith('"')) {
                const text = part.slice(1, -1);
                if (!entry.message || !entry.message.toLowerCase().includes(text)) {
                    return false;
                }
            } else if (part.includes(':')) {
                const [field, value] = part.split(':');
                if (entry.fields && entry.fields[field]) {
                    if (!String(entry.fields[field]).toLowerCase().includes(value)) {
                        return false;
                    }
                } else if (entry[field]) {
                    if (!String(entry[field]).toLowerCase().includes(value)) {
                        return false;
                    }
                }
            } else {
                // Plain text search in message
                if (!entry.message || !entry.message.toLowerCase().includes(part)) {
                    return false;
                }
            }
        }
        return true;
    }

    // Render key=value pairs from entry.fields for kvpairs column type
    // ========== Log Viewer Functions ==========

    function renderLogViewerEntry(entry) {
        renderLogEntry(entry, {
            container: document.getElementById('logviewer-log'),
            layout: logViewerLayout,
            fieldMap: logViewerFieldMap,
            formatTs: (ts) => formatTimestamp(ts, logViewerTimestampAbsolute),
            onExpand: expandLogViewerEntry,
            entryIndex: logViewerFilteredEntries.length - 1
        });
    }

    function formatLogViewerTimestamp(timestamp) {
        return formatTimestamp(timestamp, logViewerTimestampAbsolute);
    }

    function scrollLogViewerToBottom() {
        const logEl = document.getElementById('logviewer-log');
        logEl.scrollTop = logEl.scrollHeight;
    }

    function handleLogViewerScroll() {
        const logEl = document.getElementById('logviewer-log');
        const isAtBottom = logEl.scrollHeight - logEl.scrollTop <= logEl.clientHeight + 50;
        const isNearTop = logEl.scrollTop < 100;

        if (isAtBottom && !logViewerFollowing) {
            // User scrolled back to bottom, resume following
            logViewerFollowing = true;
            logViewerNewLinesCount = 0;
            updateLogViewerModeUI();
        } else if (!isAtBottom && logViewerFollowing) {
            // User scrolled up, pause following
            logViewerFollowing = false;
            updateLogViewerModeUI();
        }

        // Load more entries when scrolled near top
        if (isNearTop && !logViewerLoadingMore && !logViewerNoMoreEntries && logViewerOldestSeq !== null) {
            loadMoreLogViewerEntries();
        }
    }

    function loadMoreLogViewerEntries() {
        if (!logViewerWs || logViewerWs.readyState !== WebSocket.OPEN) return;
        if (logViewerLoadingMore || logViewerNoMoreEntries) return;
        if (logViewerOldestSeq === null) return;

        logViewerLoadingMore = true;
        logViewerWs.send(JSON.stringify({
            type: 'load_more',
            before_seq: logViewerOldestSeq,
            limit: 100
        }));
    }

    function toggleLogViewerFollowing() {
        logViewerFollowing = !logViewerFollowing;
        if (logViewerFollowing) {
            jumpToLatestLogs();
        }
        updateLogViewerModeUI();
    }

    function jumpToLatestLogs() {
        logViewerFollowing = true;
        logViewerNewLinesCount = 0;

        // Re-render any entries that were added while paused
        rerenderLogViewer();
        scrollLogViewerToBottom();
        updateLogViewerModeUI();
    }

    function updateLogViewerModeUI() {
        const modeBtn = document.getElementById('logviewer-mode-btn');
        const modeIndicator = document.getElementById('logviewer-mode-indicator');
        const modeDot = document.getElementById('logviewer-mode-dot');
        const newLinesBtn = document.getElementById('logviewer-newlines-btn');

        if (logViewerFollowing) {
            modeIndicator.textContent = 'Following';
            modeDot.className = 'logviewer-mode-dot';
            newLinesBtn.style.display = 'none';
        } else {
            modeIndicator.textContent = 'Paused';
            modeDot.className = 'logviewer-mode-dot paused';
            newLinesBtn.style.display = logViewerNewLinesCount > 0 ? 'flex' : 'none';
        }
    }

    function updateNewLinesButton() {
        const newLinesBtn = document.getElementById('logviewer-newlines-btn');
        const countSpan = document.getElementById('logviewer-newlines-count');

        if (logViewerNewLinesCount > 0 && !logViewerFollowing) {
            countSpan.textContent = '+' + logViewerNewLinesCount + ' new lines';
            newLinesBtn.style.display = 'flex';
        } else {
            newLinesBtn.style.display = 'none';
        }
    }

    function applyLogViewerFilter(event) {
        // Apply filter on Enter key
        if (event && event.key !== 'Enter') return;

        const filterInput = document.getElementById('logviewer-filter');
        logViewerFilter = filterInput.value.trim();

        // Refilter entries
        logViewerFilteredEntries = logViewerEntries.filter(e => matchesLogViewerFilter(e, logViewerFilter));
        rerenderLogViewer();

        // If filter changed, also update WebSocket filter
        if (logViewerWs && currentLogViewerName) {
            logViewerWs.send(JSON.stringify({
                type: 'filter',
                query: logViewerFilter
            }));
        }
    }

    function clearLogViewerFilter() {
        document.getElementById('logviewer-filter').value = '';
        logViewerFilter = '';
        logViewerFilteredEntries = [...logViewerEntries];
        rerenderLogViewer();

        if (logViewerWs) {
            logViewerWs.send(JSON.stringify({
                type: 'filter',
                query: ''
            }));
        }
    }

    function rerenderLogViewer() {
        const tbody = document.getElementById('logviewer-log');
        tbody.innerHTML = '';

        for (const entry of logViewerFilteredEntries) {
            renderLogViewerEntry(entry);
        }

        if (logViewerFollowing) {
            scrollLogViewerToBottom();
        }
    }

    function toggleLogViewerTimestamp() {
        logViewerTimestampAbsolute = !logViewerTimestampAbsolute;

        // Save preference to localStorage
        localStorage.setItem('trellis-logviewer-timestamp-absolute', logViewerTimestampAbsolute ? '1' : '0');

        // Update all timestamps
        updateLogViewerTimestamps();

        // Start or stop the relative time update interval
        if (logViewerTimestampAbsolute) {
            // Switching to absolute - stop the interval
            if (logViewerRelativeTimeInterval) {
                clearInterval(logViewerRelativeTimeInterval);
                logViewerRelativeTimeInterval = null;
            }
        } else {
            // Switching to relative - start updating every second
            if (!logViewerRelativeTimeInterval) {
                logViewerRelativeTimeInterval = setInterval(updateLogViewerTimestamps, 1000);
            }
        }
    }

    function updateLogViewerTimestamps() {
        const timestamps = document.querySelectorAll('.logviewer-entry .column-timestamp');
        logViewerFilteredEntries.forEach((entry, idx) => {
            if (timestamps[idx]) {
                timestamps[idx].textContent = formatLogViewerTimestamp(entry.timestamp);
            }
        });
    }

    function expandLogViewerEntry(entry) {
        expandEntry(entry, {
            expandedEl: document.getElementById('logviewer-expanded'),
            contentEl: document.getElementById('logviewer-expanded-content'),
            fieldNames: logViewerFieldNames,
            tbodySelector: '#logviewer-log',
            filteredEntries: logViewerFilteredEntries,
            onSelect: (e) => { logViewerSelectedEntry = e; }
        });
    }

    function closeLogViewerExpanded() {
        document.getElementById('logviewer-expanded').style.display = 'none';
        document.querySelectorAll('.logviewer-entry.selected').forEach(el => el.classList.remove('selected'));
        logViewerSelectedEntry = null;
    }

    function closeLogViewerWs() {
        if (logViewerWs) {
            logViewerWs.onclose = null;  // Prevent reconnect on intentional close
            logViewerWs.onerror = null;  // Prevent error logging on intentional close
            logViewerWs.close();
            logViewerWs = null;
        }
        // Stop the relative time update interval
        if (logViewerRelativeTimeInterval) {
            clearInterval(logViewerRelativeTimeInterval);
            logViewerRelativeTimeInterval = null;
        }
        currentLogViewerName = null;
        logViewerEntries = [];
        logViewerFilteredEntries = [];
    }

    function clearLogViewerLog() {
        logViewerEntries = [];
        logViewerFilteredEntries = [];
        logViewerNewLinesCount = 0;
        document.getElementById('logviewer-log').innerHTML = '';
        updateLogViewerModeUI();
    }

    // History Search Modal Functions
    let historySearchModal = null;
    let isHistoryMode = false;

    function openHistorySearchModal() {
        if (!historySearchModal) {
            historySearchModal = new bootstrap.Modal(document.getElementById('historySearchModal'));
        }
        // Pre-fill with current filter if any
        const currentFilter = document.getElementById('logviewer-filter').value;
        if (currentFilter && !document.getElementById('history-grep').value) {
            document.getElementById('history-grep').value = currentFilter;
        }
        // Default to last hour
        if (!document.getElementById('history-start').value) {
            document.getElementById('history-start').value = '1h';
        }
        document.getElementById('history-error').style.display = 'none';
        historySearchModal.show();
    }

    function setHistoryRange(preset) {
        const now = new Date();
        let start, end = 'now';

        switch (preset) {
            case '1h':
                start = '1h';
                break;
            case '4h':
                start = '4h';
                break;
            case 'today':
                start = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();
                break;
            case 'yesterday':
                const yesterday = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
                start = yesterday.toISOString();
                end = new Date(now.getFullYear(), now.getMonth(), now.getDate()).toISOString();
                break;
        }

        document.getElementById('history-start').value = start;
        document.getElementById('history-end').value = end;
    }

    function syncContextInputs(contextInput) {
        const val = parseInt(contextInput.value) || 0;
        document.getElementById('history-before').value = val;
        document.getElementById('history-after').value = val;
    }

    function parseTimeInput(input) {
        if (!input || input === 'now') {
            return new Date().toISOString();
        }

        // Duration format: 1h, 30m, 2d
        const durationMatch = input.match(/^(\d+)([hdm])$/);
        if (durationMatch) {
            const val = parseInt(durationMatch[1]);
            const unit = durationMatch[2];
            const now = new Date();
            switch (unit) {
                case 'h': now.setHours(now.getHours() - val); break;
                case 'm': now.setMinutes(now.getMinutes() - val); break;
                case 'd': now.setDate(now.getDate() - val); break;
            }
            return now.toISOString();
        }

        // Clock time: 6:30am, 14:00
        const clock12Match = input.match(/^(\d{1,2}):(\d{2})(am|pm)$/i);
        if (clock12Match) {
            let hour = parseInt(clock12Match[1]);
            const min = parseInt(clock12Match[2]);
            const ampm = clock12Match[3].toLowerCase();
            if (ampm === 'pm' && hour !== 12) hour += 12;
            if (ampm === 'am' && hour === 12) hour = 0;
            const today = new Date();
            today.setHours(hour, min, 0, 0);
            return today.toISOString();
        }

        const clock24Match = input.match(/^(\d{1,2}):(\d{2})$/);
        if (clock24Match) {
            const hour = parseInt(clock24Match[1]);
            const min = parseInt(clock24Match[2]);
            const today = new Date();
            today.setHours(hour, min, 0, 0);
            return today.toISOString();
        }

        // Try parsing as ISO date
        const parsed = new Date(input);
        if (!isNaN(parsed.getTime())) {
            return parsed.toISOString();
        }

        throw new Error(`Invalid time format: ${input}`);
    }

    async function executeHistorySearch() {
        const startInput = document.getElementById('history-start').value.trim();
        const endInput = document.getElementById('history-end').value.trim() || 'now';
        const grep = document.getElementById('history-grep').value.trim();
        const before = parseInt(document.getElementById('history-before').value) || 0;
        const after = parseInt(document.getElementById('history-after').value) || 0;
        const errorDiv = document.getElementById('history-error');
        const searchBtn = document.getElementById('history-search-btn');

        if (!startInput) {
            errorDiv.textContent = 'Start time is required';
            errorDiv.style.display = 'block';
            return;
        }

        let startTime, endTime;
        try {
            startTime = parseTimeInput(startInput);
            endTime = parseTimeInput(endInput);
        } catch (e) {
            errorDiv.textContent = e.message;
            errorDiv.style.display = 'block';
            return;
        }

        errorDiv.style.display = 'none';
        searchBtn.disabled = true;
        searchBtn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Searching...';

        try {
            // Build query URL
            let url = `/api/v1/logs/${encodeURIComponent(currentLogViewerName)}/history`;
            url += `?start=${encodeURIComponent(startTime)}`;
            url += `&end=${encodeURIComponent(endTime)}`;
            if (grep) {
                url += `&grep=${encodeURIComponent(grep)}`;
            }
            if (before > 0) {
                url += `&before=${before}`;
            }
            if (after > 0) {
                url += `&after=${after}`;
            }

            const response = await fetch(url);
            if (!response.ok) {
                const text = await response.text();
                throw new Error(text || `HTTP ${response.status}`);
            }

            const response_data = await response.json();
            // API wraps response in {data: {...}, meta: {...}}
            const data = response_data.data || response_data;

            // Close modal
            historySearchModal.hide();

            // Switch to history mode - pause live updates
            isHistoryMode = true;
            logViewerFollowing = false;

            // Cancel any pending reconnect timer
            if (logViewerReconnectTimer) {
                clearTimeout(logViewerReconnectTimer);
                logViewerReconnectTimer = null;
            }

            // Close WebSocket without triggering auto-reconnect
            if (logViewerWs) {
                logViewerWs.onclose = null;  // Prevent reconnect on intentional close
                logViewerWs.onerror = null;
                logViewerWs.close();
                logViewerWs = null;
            }

            // Update UI to show history mode
            const modeIndicator = document.getElementById('logviewer-mode-indicator');
            modeIndicator.textContent = 'History';
            document.getElementById('logviewer-mode-dot').style.backgroundColor = '#6c757d';

            // Update connection status
            const statusEl = document.getElementById('logviewer-status');
            statusEl.textContent = `${data.entries?.length || 0} results`;
            statusEl.className = 'logviewer-connection-status text-info';

            // Replace entries with history results
            logViewerEntries = data.entries || [];
            logViewerFilteredEntries = logViewerEntries;

            // Render results
            rerenderLogViewer();

        } catch (e) {
            errorDiv.textContent = e.message;
            errorDiv.style.display = 'block';
        } finally {
            searchBtn.disabled = false;
            searchBtn.innerHTML = '<i class="fa-solid fa-search"></i> Search';
        }
    }

    // Override mode toggle to restore live mode from history
    const originalToggleFollowing = toggleLogViewerFollowing;
    toggleLogViewerFollowing = function() {
        if (isHistoryMode) {
            // Exit history mode and reconnect to live stream
            isHistoryMode = false;
            logViewerEntries = [];
            logViewerFilteredEntries = [];
            document.getElementById('logviewer-log').innerHTML = '';
            connectLogViewerWs(currentLogViewerName);
            logViewerFollowing = true;
            updateLogViewerModeUI();
        } else {
            originalToggleFollowing();
        }
    };

</script>

{%= p.Footer() %}
{% endfunc %}
